 ...delle richiami di elasticità e quindi eravamo arrivati a formulare il principio delle potenze eventuali. Il principio delle potenze eventuali è alla fine di tutto, l'avevamo scritto in configurazione di riferimento e ricordiamoci che cosa è. Allora, in statica, perché ho detto che oggi ci miglioriamo allo statica, quindi trascuriamo le forze di inerzia, supponiamo cioè che i calchi siano talmente lenti che la dinamica può essere trascurata e tutto effettivamente avviene in statica. Per cui in statica abbiamo questa condizione. Questo è il, a parte il segno, la potenza degli sforzi interni, magari, volta scorsa, non mi ricordo come avevo scritto, questo era lo sforzo di Cauchy, che veniva calcolato sulla soluzione. E ha quel tensore orrendo, che però, abbiamo detto, noi non lo useremo mai, perché lavoreremo per un materiale isotrofo, quindi abbiamo dato le espressioni dirette di questo prodotto. Però gli sviluppi teorici conviene tenerlo. Quindi questa è la potenza degli sforzi interni, risulterà essere uguale al termine di volume che praticamente mai prenderemo in considerazione in questa fase poi dopo effettivamente vedremo che forze inerzia sono una forza di volume eccetera eccetera quindi consideriamo solamente la presenza di forze che possono essere applicate sul contorno e vi ricordo che questa è la potenza delle forze assegnate sulla superficie, dove ho preso il campo test, e in particolare, lo scrivo e poi dopo lo ricancello subito, quando scrivo questo termine ST0, io in realtà intendo la sommatoria su di un indice delle superfici ST0I perché le ST0I possono essere diverse se vi ricordate a seconda dell'indice in una direzione possiamo avere una superficie in un'altra direzione in un'altra e sono quindi FDII per due doppia I quindi in questo caso non vale la regola di somma sugli indici ma viene esplicitata perché sostanzialmente la novità è che devono essere integrate su superfici diverse secondo gli indici. E' un esempio una volta scorsa. Quindi, quando io scrivo questo, lo scrivo per brevità, ma intendo sempre questa cosa qui. Bisogna fare una decomposizione in base alle condizioni al contorno, cosa che abbiamo fatto, abbiamo ampiamente discusso la volta scorsa con un esempio. Ecco, questo è il principio delle potenze virtuali, ovvero la forma debole dell'equilibrio, e questo deve essere imposto, cioè questo è equivalente alla forma forte dell'equilibrio, se lo imponiamo per tutte le possibili scelte di una funzione W all'interno di un certo spazio che noi chiamiamo C0, che è lo spazio delle funzioni sufficientemente continue, diremo, per fare tutti gli integrali che ci servono, e che rispettano le condizioni, che rispettano, scusateioni che si annullano sulle superfici SU, cioè dove abbiamo i dati di diricere, dove lo spostamento è noto. Invece, chiaramente, U è scelto, U deve essere scelto nello spazio CUD. Lo cerchiamo all'interno dello spazio CUD, cioè lo spazio di tutte quelle funzioni sufficientemente continue che rispettano le condizioni al contorno sulle zone di Dirichlet che abbiamo chiamato SUI. Questo è il nostro problema. E qui c'è tutto, perché abbiamo messo la legge costituttiva e l'abbiamo messa qua dentro, l'abbiamo già sostituita. Abbiamo detto che la soluzione deve soddisfare queste condizioni e qua dentro c'è tutto. È la forma debole ma con dentro già la legge costituttiva e le condizioni al contorno sullo spostamento.icamente è il cosiddetto metodo alla Galerkin. E il metodo agli elementi finiti sarà uno specifico, un particolare metodo alla Galerkin. Quindi ciò che diciamo adesso vale assolutamente per il metodo agli elementi finiti che considereremo dopo però è di validità più generale quindi diamo un'impostazione più ampia e poi stringiamo vediamo quali sono le difficoltà e come il metodo di elementi finiti risolve queste difficoltà allora noi cerchiamo la soluzione, che chiameremo, cerco di usare la stessa notazione, un, la soluzione numerica, quindi abbandoniamo l'idea di cercare la soluzione vera del problema. Quando io parlo di soluzione vera intendo la u, la chiamo U. Quando la chiamo UN o poi negli elementi finiti metterò un pedice H, cerchiamo E adesso spieghiamo che cosa sono tutte queste cose. Cioè, decido di esprimere la mia soluzione numerica utilizzando una decomposizione. Questa prima funzione, UD, deve essere assegnata dall'utilizzatore, da chi vuole applicare questo metodo numerico. Cioè non verrà fuori dalla soluzione del problema, ma deve essere inventata a priori dall'utilizzatore. Che caratteristiche ha? Il fatto che ci sia questa DA ad abice ci lascia immaginare che abbia a che fare con il dato di Dirichlet. Infatti è una funzione che certamente deve essere nello spazio C U D, cioè deve rispettare le condizioni al contorno, ma è una estensione qualsivoglia di queste condizioni al contorno a tutto il dominio. A tutto il dominio. Che vi ricordate il problema della diffusione avevamo risolto il problema della diffusione 1D e avevamo una condizione a contorno sulla temperatura TD ok, quindi il fatto che la temperatura deve essere uguale a TD sull'estremo del raggio è la condizione a contorno la funzionezione, quella funzione che sto cercando di immaginare, è un'estrizione qualsivoglia a tutto il dominio. Potrebbe essere lineare, potrebbe essere parabolica, potrebbe essere qualsivoglia, non importa. L'unica condizione che noi imponiamo è che rispetti le condizioni del contorno e che sia definita su tutto il dominio. La costruzione di questa funzione può essere molto problematico. Con il metodo di lineamenti finiti sarà invece particolarmente semplice. Su una geometria arbitraria, perché su una geometria semplicissima come questo segmento la costruzione è una banalità, cioè possiamo inventare mille di modi di rispettare questa condizione del contorno e di estendere assolutamente il dominio, ma in una geometria bidimensionale e tridimensionale potrebbe diventare veramente un bel pasticcio, quindi il metodo di elementi uniti affronterà anche questo problema, come costruire in maniera automatica questa funzione. Quindi ricordatevi, quando vedete la parentesi qua sopra, vuol dire che non è il dato, ma è la funzione che estende il dato a tutto il dominio. Infatti deve essere definita per ogni x. Poi, questo quindi è assegnato dall'utilizzatore. E poi rimane questa parte qua. Questa parte è espressa come la somma di n contributi. n è la dimensione dello spazio all'interno del quale cerchiamo la nostra soluzione numerica. E n poi lo ritroviamo anche a pedice di U. Quindi questa n, n grande grande a pedice di u ci ricorda qual è la dimensione dello spazio all'interno del quale stiamo cercando la soluzione. Gli alfa sono dei coefficienti, gli alfa j, scusate, io l'ho scritto lì ma poi ho usato la lettera j, quindi scusatemi, bisogna ritornare indietro e mettere j perché la somm sommatoria è su j. Gli fj sono dei coefficienti scalari incogniti, rappresenteranno le incognite del nostro problema. Però sono scalari. Questi sono moltiplicati per delle funzioni vettoriali, cioè che hanno tutte le componenti, che chiamiamo fij, che sono una funzione di x, sono delle funzioni che sono definite su tutto il dominio. Le chiameremo funzioni di forma globali. Che proprietà devono avere queste funzioni di forma globali? Beh, devono essere sufficientemente continue, ok, perché dovremo derivarle e percolare le deformazioni, dovremo integrarle, quindi queste operazioni devono essere possibili. In generale l'unica richiesta che faremo è che siano continue, poi differenziabili, non con continuità ma differenziabili. Ma la cosa più importante è che se la soluzione un deve stare anche lei nello spazio CUD, e allora la soluzione più semplice è richiedere che ciascuna di queste funzioni di forma sia di tipo C0. Fij stia nello spazio C0. Perché se ogni Fij è nello spazio C0, cioè si annulla laddove abbiamo imposto delle condizioni di contorno, allora certamente questa funzione che noi stiamo creando, un, starà nello spazio C, D. Ok? Questa è la scelta tipica. Dunque, queste funzioni di forma devono rispettare questa condizione, essere continue e rispettare questa condizione. Chi le da, chi le assegna, ancora una volta, è l'utilizzatore che deve essere in grado di costruire un numero sufficiente di queste funzioni di forma per generare uno spazio sufficientemente ricco. Allora, quindi, ricordiamoci, abbiamo decomposto la soluzione numerica che cerchiamo in una parte che rispetta le condizioni al contorno, definita su tutto il dominio, e una parte che invece è C0. Gli incogniti sono queste alfa. Anche qui il metodo degli elementi finiti risponderà a questo quesito come costruiamo queste phi. Non è facile in generale, con il metodo di elementi finiti invece diventerà molto automatico. Allora la prima osservazione fondamentale è che abbiamo abbandonato facendo questa scelta abbiamo abbandonato certamente l'idea di cercare la soluzione in uno spazio a dimensione infinita. Ma noi stiamo cercando or ormai ci siamo rassegnati, e questa è la scelta di base di tutti i metri numerici, a cercare U in uno spazio che chiamerò CnUd, cioè nello spazio a dimensione finita che è stato introdotto scegliendo queste funzioni di forma. Quindi la soluzione numerica vive in uno spazio a dimensione finita. La prima grande differenza rispetto a prima. Ok, quindi questa è la prima scelta, la prima cosa. Però nel principio delle potenze virtuali non appare solamente lo spostamento, appare anche la W, che è la funzione test. Ora noi dobbiamo imporre il principio delle potenze virtuali per tutte le possibili scelte di W nello spazio, che era uno spazio a dimensione infinita prima. Lo stesso spazio in cui cercavamo una soluzione, l'unica condizione diversa era che si dovevano annullare sulle zone di Richelieu. Quindi è del tutto naturale adesso cercare la W all'interno dello stesso spazio a dimensione finita. E come la esprimeremo w? Beh, certamente l'equivalente di questo primo termine non ci sarà, perché w si deve annullare sulla porzione di Dirichlet. E quindi l'estensione più ovvia di una funzione che si annulla è l'estensione nulla, quindi 0. Qui non metteremo nulla, assolutamente niente, non c'è. Non lo scrivo, l'ho scritto 0 per metterlo in evidenza, ma se lo tolgo. Quindi W sarà semplicemente una combinazione, e uso l'indice I per sommare, da 1 ad n, delle stesse funzioni di forma, delle stesse funzioni di forma, phi di x, moltiplicate per dei coefficienti che ovviamente saranno diversi dagli alfa, li chiamo beta, beta i. W è indipendente da U, W è una funzione test, quindi la combinazione di queste funzioni utilizza dei coefficienti diversi. Però lo spazio all'interno di cui vive W è lo stesso, a parte l'assenza di questo termine che tiene conto delle condizioni d'autorno, lo spazio è lo stesso ed è del tutto naturale, è coerente con l'impostazione iniziale. Quindi imporremo, noi ci adatteremo a cercare la soluzione numerica, quindi WUN, qualunque W nello spazio CN e UN appartiene a questo spazio CN. Quindi il problema continuo viene sostituito con un problema discreto in cui ci limitiamo a cercare una soluzione in uno spazio finito e imponiamo il principio delle potenze virtuali per tutte le possibili scelte all'interno dello stesso identico spazio. Ora, gli approcci che usano lo stesso spazio per rappresentare la soluzione e la funzione test si chiama un approccio alla Galerkin, quindi niente di particolare. Ok, questo è il punto di partenza fondamentale. Notate che poi metteremo tutti i coefficienti alfa all'interno di una lista e metteremo tutti quanti i coefficienti beta all'interno di una lista. Quindi tra un po' ci troveremo a lavorare con queste liste. Siete d'accordo? Certamente sì, abbiamo l'idea che la scelta dello spazio sarà molto critica. E più ricco sarà lo spazio, migliore sarà l'approssimazione. Anche questo lo troveremo. Il metodo di elementi viniti offre una maniera abbastanza semplice per arricchire progressivamente questo spazio riducendo la dimensione degli elementi con cui divideremo il dominio e ci sono delle teorie di convergenza che ci dicono effettivamente che la soluzione tende alla soluzione esatta con una velocità che dipende dalla taglia degli elementi. Andremo solo qualche vaghissima nozione di convergenza che è un argomento di analisi numerica, matematici, quateroni, bravissimo a fare queste cose. Allora, va bene, abbiamo fatto le nostre scelte, le cose complicate sono tutte qui, la scelta della dimensione, la costruzione di questa funzione, l'invenzione di queste funzioni di forma. Non abbiamo detto assolutamente come si fa, anche perché dopo lo vedremo passo a passo, ma immaginiamo di averlo fatto. A questo punto rimane solamente una procedura molto tecnica, perché bisogna sostituire all'interno del principio delle potenze virtuali queste scelte e imporle per tutte le scelte possibili della funzione W. Secondo voi cosa vorrà dire imporre il principio delle potenze virtuali per tutte le scelte possibili di W? Beh, se andiamo a vedere, le scelte si riducono a scegliere questi beta. Quindi noi faremo l'imposizione del PPI per ogni scelta possibile dei coefficienti beta. Quindi, ad esempio, imporremo il primo uguale a 1, tutti gli altri a 0, il secondo uguale a 1, tutti gli altri a 0 e così via. Ma lo facciamo dopo. Allora, programmo adesso a sostituire all'interno del funcino delle potenze virtuali la nostra funzione, no? E... Allora, abbiamo l'integrale, avremo l'integrale sulla omega 0, epsilon di u, che sarà epsilon u di, non metto più la dipendenza da x, per andare un pochino più veloce, più la sommatoria su j, la sommatoria su j di alpha j, phi j, ok? Contratto con a, contratto con y valutato su W, che però sarà la sommatoria su i, di beta i per la phi, ok? Quindi questo è in di omega. E qua invece nel termine noto avremo st0, l'integrale sulla sua office st0 di fd. fd è un dato, quindi non cambia assolutamente niente, che moltiubica la sommatoria, beta i, beta i, ok, integrato sulla superficie. Solo ho sostituito là dentro. Allora, adesso teniamo a sinistra i termini che dipendono dalle incognite del nostro problema. Attenzione che le incognite del nostro problema sono solo le alfa, perché le beta non sono incognite. Le beta sono dei parametri arbitrari. Le incognite sono le alfa. Allora, teniamo a sinistra solamente i termini che dipendono dall'alfa e quindi sarà questa sommatoria che moltiplica questo termine e invece tutti i termini, questo epsilon su d e le forze, daranno dei contributi che teniamo a destra, li separiamo a destra. Allora, io qui ho scritto alfa i, però scusate, cerco di mantenere gli indici perché sono molto importanti, alfa j, non l'ho sbagliato a copiare, l'indice delle beta è i, invece l'indice degli alfa è j. Allora, e quindi comincio a riscrivere questo termine, dato al punto di questo, dell'a per quest'altro. E avremo quindi una doppia sommatoria, faremo sommatoria su j, e la scrivo in questa maniera, scrivo beta i, scrivo prima beta i, poi io chiamo k i j un coefficiente, che adesso insieme determineremo, cercheremo di capire, che moltiplica alfa j. Allora, io ho innanzitutto scritto prima beta, vabbè, ma non cambia niente, e poi alfa J, no? Quindi alfa J è finito qui, beta I è finito là. Secondo voi che cos'è questo Kij? Kij è quello che resta, Kij sarà l'integrale su omega 0 di che cosa? Di epsilon valutato su phi j, contratto con A, contratto con y valutato su phi. Sappiamo fare questo integrale? Potrà essere difficile, ma abbiamo tutti gli elementi, perché queste funzioni di forma le conosciamo. Quindi possiamo calcolare le y, cioè la parte similica del gradiente, e fare questo integrale. Lo possiamo fare. Sarà difficile. Anche qui gli elementi finiti ci aiuteranno. Risolveranno il terzo e ultimo problema. Come integrare queste cose. Quindi i problemi che gli elementi finiti risolveranno sono come costruire questa funzione in D, come costruire in maniera automatica le funzioni di forma, in maniera semplice e arricchirle facilmente, come calcolare questi integrali. Però se ti dà accordo che in teoria non c'è un ostacolo a valutare questi K i j. E poi dopo porto a destra gli altri termini, che dipendono solamente dall'indice i, quindi avremo solamente la sommatoria su i. Allora, portando a destra questo termine, avremo quindi un meno, avremo innanzitutto il meno, y valutato su ud, ma ud è noto, per cui non c'è nessuna incognita. Contratto con a, contratto, no scusate, sto mischiando il modo di fare, scusate, l'integrale lo scrivo dopo, avremo la beta i, perché qui c'è beta i, che moltifica un coefficiente che chiameremo fui. Adesso dobbiamo stabilire com'è fatto questo coefficiente. Questo termine tiene conto dello spostamento assegnato. Quindi come sarà fatto questo fui? È quello che devo scrivere adesso, lo stavo scrivendo prima. Contiene l'integrale su omega 0 di Epsilon UD di Epsilon UD contratto con A, contratto con Fi. Con Fi. Ok?, anche qui è difficile, certamente questo integrale è difficile tanto quanto il primo, vedremo come si fanno. E poi c'è l'ultimo termine che è questo, che contiene i coefficienti arbitrali beta e le forze assegnate e quindi lo scriverò come sommatoria su i di beta i che moltiplica fe e poi dopo vedremo, anzi facciamo così, f ext i dove questo f ext tiene conto del fatto che qui abbiamo delle forze esterne assegnate. Ecco come è fatto questo FxI, che è semplicemente uguale, semplicemente tra virgolette, perché può essere complicato, St0 di Fd scalar phi in di S. Anche qui, se siamo in grado di calcolare questa internazione, siamo a posto. Va bene? Allora, tipicamente, vedete che questi due termini sono molto simili fra di loro, allora si sommano questi due e li chiameremo a sommatoria di beta i per f, dove chiaramente f è dato da fx meno f1. Mettiamo assieme le cose e lo esprimo in una maniera però leggermente diversa. Allora, questi integrali li avete nelle dispense, quindi ho bisogno di un po' di spazio al cancello. Guardate che veramente se dovete un'occhiata alle dispense seguono pari pari quello che vi sto facendo. Quindi io cerco di mettervi nella condizione più agevole possibile per gli appunti. Allora, invece lo scriverò così, lo scriverò in questa maniera, beta trasposto k alta, che è questo termine, uguale a beta trasposto f, invece di scriverlo con l'indice questi sono i prodotti che entrano dove effettivamente questo è un beta vettore colonna quindi trasposto fa riga, matrice, colonna e poi aggiungo l'ultima cosa perché non l'ho più scritta che questo principio delle potenze virtuali deve essere imposto per tutte le possibili scelte di W. Cosa vuol dire a questo livello? L'abbiamo già commentato prima. Che cosa devo aggiungere? Questo deve valere qualunque... Guardate a dimmelo voi. Qualunque... Vado a? Qualunque... W riprende dai coefficienti beta, quindi dire qualunque beta vuol dire qualunque, qualunque W vuol dire qualunque beta, qualunque scelta di beta. Ok, allora, se devo imporlo a qualunque scelta di beta, faremo le scelte che vi ho anticipato prima. Siccome lo spazio è a dimensione n, ho solo n scelte indipendenti fra di loro. E le scelte più semplici sono prendere il primo coefficiente di beta 1, gli altri 0 e così via. Se lo fate, vi ritrovate a risolvere il sistema k'A' uguale a F. E quindi, usando qualche tecnica di soluzione numerica dei sistemi lineari, scrivo formalmente K'A'1S, poi voi sapete che non si invertono mai le matrici per risolvere i sistemi lineari, ma si usano le tecniche, magari le avete imparate, le U, Cereschi, qualcosa, non so, magari qualche esame numerico un po' l'avete fatto. Comunque, ci sono mille tecniche. Se la matrice K è ben fatta, adesso diremo cosa vuol dire ben fatta, la soluzione di questo sistema è particolarmente semplice. Allora, che probabilità ha la matrice K? Beh, questo sarà fondamentale quando ad esempio calcoleremo gli autovettori, cioè le frequenze proprie dei modi di vibrare. La matrice K, se andate a vedere, i coefficienti K e J sono per natura simmetrici, cioè K e J uguale K e J. Quindi K è una matrice reale simmetrica. Ma un'altra proprietà molto importante, che se la nostra struttura, adesso dico una cosa che sarà un po' scura, poi nell'esempio che faremo sarà più chiara, Se la nostra struttura mette dei moti rigidi, ad esempio può traslare verticalmente in maniera rigida, allora la k è semidefinita positiva. Se invece blocchiamo questi moti rigidi, cioè non ci sono motri rigidi possibili, allora la K è definita positiva. Una struttura flottante, questo porto chiari, immaginatelo flottante, ha 6 gradi di libertà di moto rigido, 3 traslazioni, 3 rotazioni. Quindi in questo caso la matrice di rigidezza sarebbe semidefinita positiva. Se invece la prendo e la blocco con dei vincoli isostatici, come facevate con le tradi, la meccanica della struttura, allora diventa definita positiva. Per risolvere un sistema con una matrice definita positiva ci sono delle tecniche robustissime e la più robusta di tutte è la decomposizione di Cioveschi. Comunque, come si faccia a risolvere questo sistema? Per nostra fortuna non sarà un problema. Diremo a Matlab, prenditi questa matrice, guardatela, analizza e scegli la tecnica migliore per risolverla. E noi useremo il backlash. Sapendo che la soluzione di un grosso sistema lineare può essere il problema più grande dei lineamenti finiti, in queste milioni di incognite, può avere milioni di incognite e se la matrice non è ben fatta può essere un problema gigantesco. Va bene, quindi questa in breve è la soluzione del nostro problema, la Galerkin, e poi dopo una volta che abbiamo questo alfa, che è una alfa soluzione, chiamiamolo alfa barra, allora ritorniamo e invece di dire ok, un sarà un generico alfa, no, prendiamo proprio l'alfa soluzione del nostro problema e quella è la miglior scelta possibile che noi possiamo fare della nostra soluzione numerica. E da lì, se abbiamo gli spostamenti, possiamo calcolare tutte le cose che vogliamo. Possiamo calcolare le deformazioni e con la legge costituttiva possiamo calcolare gli sforzi in ogni punto della struttura. Ok? Questo è lo schema generale che dovete tenere in mente perché quando poi comincieremo a parlare degli elementi finiti, siccome ci sono tante cose tecniche in mezzo, il rischio è perdere di vista questo schema globale. Quello che faremo con gli elementi finiti saranno esattamente questi step. Costruire questa cosa, costruire queste, inserire nel principio delle potenze virtuali, calcolare le integrali, risolvere il sistema. È questo schema. Quindi teniamolo ben a mente. Vi ho detto che queste vengono chiamate funzioni in forma globali, oggi capiremo perché, insisto sul definirle globali, in opposizione a locali, che sarà la prima cosa che vedremo invece nel momento agli eventi finiti, e con un po' di fatica noi dovremo mettere in evidenza quali sono le funzioni in forma globale del metodo FEM come si costruisce questa componente eccetera eccetera ok? però la procedura è questa e quindi ci soffermiamo un istante a dire una proprietà a pagina 33 delle dispense che avete io cercherò di lasciare la parte passata delle dispense il più stabile possibile anche se ogni tanto leggendo qualche scelmenza mi trovo, anzi se la trovate voi mi fate un gran favore se me lo dite e aggiungerò pian piano le altre parti quindi va bene comunque alla pagina 33 trovate due dimostrazioni che però adesso non facciamo, sono molto semplici e quello che ci interessa è il risultato finale, perché effettivamente la domanda che ci viene è ma in che senso questa è la soluzione migliore? Ho detto prima che è la soluzione migliore. In che senso? Cioè è la soluzione che viene da questo schema qua, ma qualcuno ci dice che è la soluzione migliore. Cosa vuol dire? Allora la proprietà che adesso vi annuncio senza dimostrazione, ma la trovate qui se volete, è la proprietà di miglior approssimazione. La proprietà di miglior approssimazione. Allora, allora, allora, abbiamo introdotto alcune cose che sono la soluzione reale del problema, la chiamiamo, scusate, dovrei chiamarla la soluzione esatta del problema, quella che è inaccessibile in generale, quella che non riusciremo mai a conoscere, però esiste, da qualche parte c'è, magari nei nostri sogni. Poi c'è la soluzione numerica, un, ok? Che è quella che abbiamo calcolato con questa procedura, che ovviamente sarà diversa dalla soluzione esatta, no? Ci sarà un errore e effettivamente noi chiameremo delta u questo errore, u meno un. E vogliamo dire qualcosa sull'entità di questo errore, sull'entità di questo errore. Ora, quando volete dare l'entità di un campo vettoriale, perché questo dipende da x all'interno della struttura, si usano le norme, ad esempio la norma L2, cioè si fa il prodotto e poi si integra, però non è un'ottima norma perché in generale quello che ha un interesse meccanica dei solidi è controllare non tanto la convergenza degli spostamenti ma soprattutto le deformazioni e gli sforzi che dipendono linearmente dalle deformazioni, perché è questo che ha un interesse effettivamente calcolare. Allora si utilizza, avrebbe senso magari calcolare una norma H1 che fa apparire anche il gradiente. Noi usiamo invece un'altra norma che è strettamente legata a quello che stiamo facendo. Noi useremo la cosiddetta norma energia, la cosiddetta norma energia, che è la cosa seguente. Epsilon. Ecco, questa cosa qua, che è estremamente associata alle quantità che abbiamo calcolato prima. Se i muoti rigidi della struttura sono bloccati, nel senso che dicevo prima, questa è una vera e propria norma, equivalente alla norma H1. Ed è una norma, come vedete, che interviene sul gradiente dell'incognita, perché Y non è la parte simmetrica del gradiente di U. Quindi, in un certo senso, calcolando questa quantità, controlliamo l'ensità dell'errore sul gradiente di questo delta u. Quindi, questa integrale ci dice quanto errore stiamo facendo sul gradiente della soluzione, della soluzione numerica rispetto alla soluzione reale. Quindi come norma per valutare l'errore utilizzeremo questa norma energia, perché è la norma più classica degli elementi finiti, equivalente alla norma H1 di Sopopro, quindi molto potente. Allora, il terzo elemento è un, introduciamo un ulteriore vettore S, che è un generico elemento dello spazio Cnud. Cioè è un generico vettore che chiameremo cinematicamente ammissibile. Cioè è un altro vettore che può essere scritto in questa maniera, con una scelta diversa però di alfa. Con un'altra scelta di alfa. Certamente la soluzione un appartiene allo spazio CUD, quindi S e un possibile S, però le scelte possibili di S sono molto più ampie della singola soluzione, perché qualunque alfa genera un S ammissibile. Qualunque scelta di alfa otteniamo un S ammissibile. Allora il risultato che è abbastanza facile da dimostrare è che se prendiamo l'integrale della norma energia, Epsilon su delta U, contratto con A, contratto con Epsilon su delta U, quindi omega, allora questo è minore uguale, cioè l'errore che facciamo, l'errore che esiste, mettiamola così, l'errore che esiste fra la soluzione esatta e la soluzione numerica, perché delta u è questo, la differenza fra la soluzione esatta e la soluzione numerica, risulta essere minore o uguale dell'errore tra la soluzione esatta e il generico vettore S. Cioè, se noi prendiamo a capocchia un S dello spazio, l'errore rispetto alla soluzione esatta sarà certamente maggiore dell'errore che abbiamo rispetto alla soluzione numerica. Ovviamente l'ugale vale quando S coincide con la soluzione numerica, perché allora questo termine è uguale a quello di prima, questo termine a destra è uguale a quello di sinistra. Se S è la soluzione numerica, otteniamo delta U. Ma se S non è la soluzione numerica, questo oggetto è strettamente maggiore di quest'altro. Quindi, sostanzialmente, cosa fa il metodo Laguer-Herkhin? È un metodo molto intelligente, perché fra tutte le funzioni cinematicamente ammissibili, fra tutte le funzioni cinematicamente ammissibili, sceglie proprio quella che ha errore in norma energia minimo. In un certo senso, quindi, non possiamo sperare di fare meglio. Quindi complicata, come è possibile creare Ud? Come è creare Fi? Com'è possibile fare l'integrale? Ci si sbatte subito, si va subito a sbattere contro questa difficoltà, in modo che il moitro log alert non servirebbe assolutamente a niente, a nulla di più di una soluzione analitica, se non fosse stato inventato il metro degli elementi finiti. Adesso, prima di lanciarci a spiegare cos'è il metro degli elementi finissimo, anzi vi consiglio se avete di procedere insieme a me perché se avete difficoltà io vi aiuto
 Tutti i grandi codici ed elementi finiti hanno al loro interno un pre-processore, un post-processore per generare la mesh ed è probabilmente la parte più complessa del codice oppure ci sono dei pre-processori esterni che costano l'ira di Dio, tanto per darvi un'idea una licenza di uno dei codici in meccanica dei solidi più diffusi e più affidabili che si chiama Abagus costa intorno ai 20-30 mila euro all'anno con una licenza cioè sono cose che costano un sacco ora per fare i nostri giochetti G-Mesh è perfetto permette di fare anche tante cose soprattutto è programmabile è parametrico quindi si può definire la Mesh in funzione di tanti parametri come vedremo e quindi rapidamente cambiare la mesh cambiare le dimensioni raffinare la mesh eccetera eccetera è un giocattolo sapendo che è un giocattolo però se andate all'interno del sito Gmash vi fa vedere una baranga di strutture ad esempio questa flange l'han creata loro poi io avevo fatto sopra un codice di calore, è estremamente facile, noi non faremo problemi 3D perché tecnicamente sono un po' più complicati, ci metteremo al 2D. Un aneddoto, io a un certo punto lavoravo con un amico francese che si occupava di cavità, si occupa ancora di cavità, di cavità nel sale. Ora, io ignoravo che ci fossero queste cose, ma il mondo è pieno di giacimenti di sale. E allora le persone hanno pensato bene di utilizzare questi giacimenti. Si scava sciogliendo il sale, il sale è molto impermeabile, si fanno dei giacimenti, queste colonne qua sono dei giacimenti alti 10-20 km dove vengono stoccate tutte le cose che l'uomo non vuole tenere in superficie dai fiuti nucleari in Francia al petrolio negli Stati Uniti le riserve strategiche di petrolio negli Stati Uniti sono in Texas in cavità sotterranea e nel sale adesso si vog si vogliono toccare l'idrogeno per utilizzi nella transizione energetica, cioè quando le forti rinnovabili generano troppe energie e non sai cosa fartene, allora un'idea è quella di generare idrogeno, toccarlo all'interno di queste cavità e poi utilizzarlo in qualche maniera quando invece c'è carenza di energia. Allora avevamo la necessità di analizzare tutte queste cavità che non si conosce bene la forma, sono molto irregolari, allora si hanno delle misure sonar, mai detto con un sonar, e avevamo quindi l'esigenza di fare una stratigrafia geologica secondo tutte queste foglie, faglie, e riprodurre la geometria delle cavità e poi fare l'analisi, un'analisi viscoplastica del solido con evoluzione perché quando poi chiudete queste cavità diventano delle bombe perché si riscalda tutto quello che c'è dentro e negli Stati Uniti sono stati problemi pazzesti. Abbiamo cercato con tutti i codici e le sostituzioni di fare questa cosa impossibile e alla fine siamo ritornati a casa e con Gmash abbiamo fatto queste Mesh complicatissime per dire è un giocattolo? Sì, non troppo, se lo si sa utilizzare bene. Ok, allora, cosa lo usiamo? Lo usiamo per fare, ad esempio, la mesh di questo esempio, che è l'esempio che trovate nell'appendice. Non ha nessun significato, però mette assieme, in realtà sì, perché vedrete che la piastra forata è un benchmark classico. Abbiamo questo solido, si parla di problemi bidimensionali, per di più in plane strain, cioè deformazione piana. Cosa vuol dire? Che lo spostamento fuori da piano è nullo per ipotesi. Quindi c'è tutta un'ampia casistica di problemi, quelli che si sviluppano molto nella terza direzione e che per simmetria non possono avere deformazioni nella terza direzione, per le gallerie, le grandi dighe, ciò. E comunque ci sono due ipotesi classiche che si fanno per ridurre un problema tridimensionale e bidimensionale, una è plane strain, l'altra è plane stress, cioè le strutture molto sottili non hanno sforzo in direzione 3. Si può modificare facilissimamente il codice per fare anche plane stress, ma noi abbiamo la versione plane stress, plane strain. Allora, qui ne abbiamo, quali sono le condizioni con tono? Le abbiamo viste l'altro giorno, qui abbiamo dei carrelli che vincolano lo spostamento orizzontale, però la forza in direzione verticale è zero. Poi abbiamo il foro che è soggetto a pressione, il bordo di destra imponiamo uno spostamento uniforme in orizzontale, invece in verticale i carrelli non possono applicare forze, quindi la forza è zero. E poi vedete che io ho aggiunto questo carellino qua sotto. Allora, se io non avessi questo carellino lì sotto, voi, senza aver nessuna nozione di cinematica, vedreste che questo può scorrere in verticale. Quindi c'è un atto di moto rigido ammissibile. Siccome io voglio lavorare con delle matrici positive, definite positive, allora metto un carellino in quel nodo per bloccare la possibilità di moto rigido. È un vincolo isostatico, ricordatevi, chi era? Bocciarelli o Carvelli? Bocciarelli. Il buon Bocciarelli, vincoli isostatici, questo è un vincolo isostatico per bloccare il grado di libertà verticale. Quindi noi vorremmo riprodurre fedelmente questo problema. Allora, per far andare Gmash abbiamo bisogno di tre file. Allora, il primo, voi l'avete già questo, Elasticity Appendix Geo, nella directory input. Quindi, insieme a me adesso guardiamo cosa c'è scritto. Purtroppo il proiettore fa veramente schifo. Si vede poco. Cerchiamo di... Insomma, estremamente intuitivo. Creazione della mesh. Allora, innanzitutto, prima di tutto assegniamo le dimensioni globali del nostro problema. H orizzontale, V verticale, R il raggio del cerchio. Sono questi i tre parametri. Poi, anzi facciamo così, magari riesco a farvelo vedere meglio. No, ma qui ho tutto quello che mi serve, quindi effettivamente è meglio tenere questa slide. Allora, poi definisco alcuni parametri che saranno il livello di raffinamento che chiederemo a Gmash per la mesh, nella creazione della mesh. Questi numeri sono praticamente delle dimensioni caratteristiche degli elementi in corrispondenza di alcuni punti che definiremo. Quindi vedete che questi LC1 ed LC2 appaiono nella definizione di tutti i punti, nella definizione di tutti i punti qua. Allora, si comincia, si fa un bottom-up, si comincia a definire l'entità di dimensioni inferiori, quindi i punti, poi dovremo collegarli con linee e poi creeremo la superficie. Facilissimo. Non preoccupatevi, nessuno scrive mai tutte queste cose da zero, si fa copia e incolla sempre dai file che ci sono già a disposizione e si modificano poche cose. Voi poi, tramponi, creerete due o tre per fare degli esercizi. Si comincia a definire i vari punti, punto 1, 2, 3, 4, in funzione delle coordinate che abbiamo definito prima, la terza coordinata è sempre 0 perché siamo nel piano, e io voglio quindi che in corrispondenza del punto 1, 2, 3, 4 la mesh generata dalla gmesh abbia più o meno dimensione 0,5 cioè la taglia caratteristica dell'elemento dovrà essere di quest'ordine adesso non so se nel vostro file perché l'ho sempre modificato non so se è esattamente ancora così se questi parametri sono identici perché poi li cambierete per vedere come una mesh diventa più o meno fine, quindi può essere benissimo che nella versione che avete sia diversa. Poi devo definire i punti di cui ho bisogno per creare il cerchio, perché il cerchio sta sempre bisogno del centro, punto 5, e poi è sempre meglio dividerlo in archi, strettamente migliori di 180, allora io taglio corto e faccio degli archi di pieghe comezzi. Non è la sola maniera per creare le geometrie ormai in Gmesh si può anche usare OpenCascade che ha delle primitive se veramente volete semmai dovrete utilizzarlo dovrete imparare a usarlo bene quindi ma qui abbiamo bisogno veramente di pochissime cose quindi cominciamo a creare il centro e poi 6, 7, 8 e 9 che sono i punti agli estremi di quest'archi. Ok? Ok, abbiamo fatto i punti. Tutto quello che ci serve per creare le linee e poi passiamo alle linee. La linea 1 congiunge, vedete in rosso ci sono i numeri di linee, va da qui a qui. La linea 2 va fino a qui e così via, la 3 e la 4. Le prime quattro linee definiscono un line loop. Notate che io uso un numero crescente per l'entità linea, così come usavo un numero crescente per l'entità punto. Ok, quindi definisco un loop, questo sarà il bordo esterno della superficie che dovrò creare, loop 5 contiene le curve 1, 2, 3, 4. Sarà quindi questo il bordo esterno della superficie. Poi definisco il cerchio con queste keywords. Il cerchio si definisce dando il punto di inizio, il centro e il punto di fine. Quindi questo è un arco di cerchio che da 7 va a 6. È un po' strano, perché vado da 7 a 6? Ma perché i bordi esterni devono essere definiti in senso anti-orario, i bordi interni devono essere definiti in senso orario, perché? Ma perché io voglio che la normale, il criterio è questo, la normale deve essere uscente, quindi ho una terna che è costituita da la tangente, no scusate, la normale, la tangente Z, deve essere una terna a destra. Sul bordo esterno quindi deve andare così, se lo percorro così, la normale è uscente e Z è fuori dal piano. Sul bordo interno invece, se la normale deve essere uscente, la devo percorrerla questa maniera. Tangente, normale, proprio qua, scusate. Se la normale deve essere uscente, ma sì, ho detto normale tangente Z. La prima è la normale, la seconda è la tangente e la Z. Quindi il bordo interno deve essere percorso in senso inverso. Per cui definisco le curve in verso orario e così via, le definisco tutte e quattro. C'è una guida, l'appendice riguida nella creazione di questi file input, niente di che. Poi, una volta che abbiamo creato i quattro archi, possiamo creare un'altra curva, un'altra delta omega, che è data dall'unione di 6, 7, 8 e 9. Che strano, perché ho cambiato i segni 8 e 9? Andiamo a vedere come ho definito 8. È un esercizio. L'8 l'ho definito da 8 con centro 5 fino a 9. Quindi da 8 con centro 5 fino a 9. Quindi ho volutamente sbagliato direzione, ho sbagliato verso, ho ricominciato a definirlo in senso orario. Quindi quando gli chiedo di creare un looper, cambio il segno per dare il senso giusto al looper. Quindi si possono usare anche i segni, più o meno, per orientare bene. Va bene, ho creato il bordo esterno e il bordo interno, sono pronto a chiedergli di creare una superficie. Con questo comando, blind surface, do prima il bordo esterno e al bordo interno sono pronto a chiedergli di creare una superficie con questo comando, plane surface, do prima al bordo esterno che era il 5 e poi al bordo interno che è il 10 e lui crea quindi una superficie provate a lanciare il gmesh e facciamo insieme lanciare il gmesh poi dopo continuiamo a spiegare che cos'è il resto lo faccio anch'io questo è il a voi magari verrà con un colore azzurrino dentro, non lo so io l'ho tolto dalle impostazioni vado in file qua sopra, apro vado all'interno di input della directory input e vado a cercare elasticity appendix geo cioè il file che stiamo analizzando a me viene questa cosa qui magari voi non avete i colori degli elementi se siete riusciti a aprire? Ok, allora, per cambiare visualizzazione probabilmente a voi basta fare questo. Andate su Mesh, qua, vedete che c'è scritto Mesh, anzi no, probabilmente era Tools Options. Ecco, se andate su Tools Options, vi si apre questa finestrella di dialogo, andate su Mesh e voi probabilmente non avete cliccato questo 2D Element Faces. Se cliccate 2D Element Faces vi viene fuori il colore. Quindi lui ha generato questa superficie e come vedete l'ha divisa in tanti elementi triangolari che sono i nostri elementi finiti. Però su questo torniamo dopo. Solo un po' per giocare e vedere come si fa, andate su Tools, Options, ancora. Poi invece togliete la mesh, togliendo quindi i due cosi cliccati, e rimane solamente la geometria blu. Rimane solo la geometria blu. Allora andate su Geometry, e trovate una nuova finestra di dialogo, se cliccate su Point Levels e Curve Levels, vi dà tutte le informazioni e vi dice quali sono le levels che avete appena creato. Ad esempio i punti sono 1, 2, 3, quelli che abbiamo appena fatto. Le curve vi dà un sacco di informazioni. A un certo punto vedete che si mischiano un prof di loro, perché appare questa cosa qui physical, physical curve. Cioè la linea 4 ha sottoscritto physical curve. Che cosa sono queste cose? E dove le abbiamo soprattutto definite? E da dove chi le ha tirate fuori? Ritorniamo sulla slide. Vedete che quindi qua, dopo aver creato la superficie, definiscono queste physical entities. A che servono queste physical entities? Sono le cose su cui dovrò imporre le condizioni al contorno. E poi avrò anche una physical surface, perché io associerò gli elementi della superficie a un materiale. Quindi devo sapere quali sono gli elementi di questa superficie. Per avere queste informazioni si usa questo strategia di creare delle entità fisiche. Lui scriverà in output solo e esclusivamente le entità fisiche che definite e avrete in ogni elemento un numerino, un tag, che corrisponde con il numero di entità fisica. Quindi poi dopo, se volete sapere quali elementi stanno sulla linea fisica 1, basterà andare a vedere dove questo tag varrà uguale a 1 o 2 o 3 o 4 e questo mi servirà per imporre le condizioni al contorno. Quindi servono due cose, 1 imporre le condizioni al contorno in spostamento e forza, e due per associare elementi di superficie a materiali. Poi questa qui sono delle cose che potete anche trascurare, definisce qual è la versione che voglio usare, l'ordine degli elementi, questo sarà molto importante, gli sto chiedendo di fare degli elementi quadratici, adesso vediamo che cos'è, l'altra opzione è, vabbè ci sono anche cose più ricche, ma noi useremo o elementi lineari o elementi quadratici, adesso vediamo che cos'è, l'altra opzione è, vabbè ci sono anche cose più ricche ma noi useremo o elementi lineari o elementi quadratici e poi gli dico, gli lancio il comando di fare la mesh della superficie e di salvare la mesh all'interno di questo file, il file .msh sarà il file creato direttamente da gmesh in cui mette tutte le informazioni della mesh. Infatti, se voi andate nel vostro directory input, trovate altri due file che si chiamano elasticity appendix. Uno è .m, lo guardiamo dopo. L'altro è l'msh che è stato creato da gmesh e che contiene una lista infinita di cose, di informazioni, che adesso andiamo a vedere. Ok? Provate a... Provate a cambiare la finezza della mesh. Invece di avere, non so, i parametri che avete, fatteli un pochino più fini, o se siete già abbastanza fine, fateli più rada, e poi, come piccolo esercizio, cambiate il raggio del cerchio. Cambiate il raggio del cerchio e fatelo uno invece che due. Banalissimi, però almeno giocando un po' ci si familiarizza con questo codicillo. Provate quindi a cambiare la taglia della mesh. Provate a mettere molto diversi i due parametri, così che sia molto raffinata vicino al cerchio e poco fuori poi provate a cambiare il raggio quando dovete creare una vostra geometria potete fare benissimo un coppia in colla da questo esempio e poi nel sito di Gmash trovate un'infinità di esempi super complicati super complicati perché veramente questo è banale questo file che abbiamo creato è banalissimo però potete mettere dei loop dei controlli generare delle parti con simmetrie particolari veramente se vi dovesse mai servire in futuro ricordatevi che potrebbe essere una buona scelta potrebbe in carità non voglio assolutamente dire che sia la scelta mia siete riusciticiti? Avete avuto qualche difficoltà? No, no, riuscito. Domanda, come si comporta quando il raggio diventa più grande del lato? Ah, si impiatta, molto semplicemente. Perché si è formata la figura però, poi con la convenzione che dicevamo prima della... Cioè ha fatto la superficie tra il cerchio e il quadrato? Esatto, l'ha fatto all'interno allora è più furbo di noi non è che ha modificato magari probabilmente la superficie è normale entrante noi l'ordine lo vedremo dopo come si definisce l'ordine ovviamente se l'ordine dei nodi nell'elemento è opposto allora lo z è è entrante. Potrebbe non essere un problema, ma se invece hai bisogno di conoscere la normale... Ok, allora, questa è la prima cosa. Il primo file geo quindi lo dovete creare voi e ricordatevi che se volete modificare la mesh dovete andare nel geo prima, salvarlo e ricreare la mesh. L'uno lo salva nella stessa identica directory dove ha preso il file input. Questo è il primo, il secondo lo crea lui, è il file mesh. E vediamo se qui c'è... eccolo qui, vedete, questo è un esempio di file mesh. Prima c'è il format, ci sono delle indicazioni che non ci interessano, poi c'è il numero di nodi, e poi comincia tutto il nodo, 3.308 nodi, ok? Vedete, fino ad arrivare alla 3.308 riga con le coordinate dell'ultimo nodo. I primi sono quelli che voi avete definito, ritrovate le coordinate che avete definito, e poi dopo gli empie tuttilli nuovi. Poi finisce i nodi con questa keyword end nodes, quindi se voi avete bisogno di leggerlo, sfruttando queste informazioni, effettivamente il MATLAB va ad ampli processore, che si chiama readMesh, che fa esattamente questo, entra qua dentro, si legge tutte le coordinate e tutta la lista di... Poi comincia con gli element elementi, ci dice che ci sono 1680 elementi divisi in due tipi, elementi di linea e elementi di superficie. Gli elementi di linea ci serviranno per imporre le condizioni a contorno, le forze, gli spostamenti e gli elementi di superficie rappresenteranno questo dominio associato ad un materiale. Allora, prima c'è il numero in ordine crescente, da 1 fino a 1680, poi il secondo è un codice che dice che elemento è. 8 sta per un elemento di linea a 3 nodi, capiremo dopo che cos'è. 9 sta per un elemento triangolare a 6 nodi, sono elementi quadratici. Ah, ecco una cosa che non vi ho fatto vedere è cosa succede se passo elementi scusate questo è importante se prendo il mio file che era io ce l'ho molto molto rosa no vado su mesh qua a sinistra, e clicco Order 1, Set Order 1. Allora, vedete che lui, invece di mesciare bene il bordo, l'ha approssimato con delle linee diritte, perché sta utilizzando degli elementi di linea a due nodi, come quelli che abbiamo fatto per la diffusione 1D quindi interpola la geometria con dei segmenti invece di seguire l'arco lo approssimo in maniera molto rosa con questi segmenti diritti quindi questi sono gli elementi di ordine 1 noi useremo sempre praticamente sempre gli elementi di ordine 2 che riescono ad interpolare anche delle curve molto molto meglio poi la rappresentazione grafica è veramente povera di Gmesh, perché lui in realtà sta interpolando in maniera quadratica le curve, però vedete che una parabola ve la rappresenta come unione di due segmenti di riti, in realtà sono veramente parabole, è solo una rappresentazione grafica. Quindi se abbiamo sull'elfe curve curve o comunque vogliamo una convergenza più rapida verso la soluzione del problema, conviene certamente utilizzare elementi quadratici. Allora, torniamo qua. Allora, quindi 8 è un... anche queste cose sono tutte scritte nell'appendice. 8 è l'elemento di linea a 3 nodi, 9 è l'elemento di superficie a 6 nodi poi abbiamo un codice che rappresenta questo terzo cosa qui è il proprio codice che non serve a niente poi abbiamo il quarto numero che vi dice qual è l'entità fisica a cui appartiene quindi queste sono l'entità fisica numero 1 qual era l'entità fisica numero 1? e la linea 2 quindi questa qua la linea 2 era questa ho ricopiato da prima ho definito l'entità fisica numero 1 la linea 2 e la linea 2 era questa Poi andiamo avanti, al certo punto vedete che l'entità fisica aumenta da 3 a 4. 4 è l'entità fisica superficie. Infatti quando arriviamo sugli elementi di superficie tutti quanti appartengono all'entità fisica numero 4. 1, questi qui sono invece le entità geometriche. Vedete che effettivamente la superficie fisica numero 4 è data dall'entità geometrica numero 1 infatti trovate questo coso ma non lo usiamo mai noi usiamo sempre solo l'entità fisica e poi vi darà la lista dei nodi la lista dei nodi quindi se abbiamo un elemento di linea 3 nodi avete solamente 3 nodi se avete invece un elemento di superficie dei nodi, quindi se abbiamo un elemento di linea a tre nodi, avrete solamente tre nodi. Se avete invece un elemento di superficie a sei nodi, avrete una lista di sei nodi. Quali sono i nodi? Beh, sono stati definiti prima. Sono quei punti che hanno le coordinate. Quindi contiene effettivamente tutte queste informazioni. Una volta che Gmash ha generato questa cosa, voi sapete ogni cosa che mi interessi della superficie, del vostro problema. Però vi dirò, non sapete neanche null'altro del loro. Quindi qui avete una lista di nodi e poi si dice una lista di elementi con la loro connettività. Che cos'è la connettività? È l'elenco dei nodi che li definiscono. Non sapete nient'altro. Quindi noi dopo, a partire da questo, dovremo generare un metodo usando solo ed esclusivamente queste informazioni. Sto mentendo. Dobbiamo ancora aggiungere l'ultimo file, il .m, che contiene le informazioni più fisiche della nostra analisi. Questo è elasticityappendix.embe, che anche voi avete ed è già preparato. È molto corto, vedete, però dà delle informazioni essenziali. Prima di tutto dice qual è il file di Mesh. Perché voi lancerete un'analisi, direte all'analisi di caricare questo file qua e quindi lui come prima informazione vi dice ok, la Mesh valla a prendere qua. Ed è il file che è appena stato creato da Gmesh. Poi definiamo varie cose, material, solid, tbc, dbcn, tbc, allora che cos'è? Material definisce materiali. In questo caso il materiale è un materiale del tutto fittizio, in elasticity, in questo codice, gli unici parametri che ci intervistano sono il modulo di Young e il coefficiente di Poisson. Del tutto fittizio in questo caso, quindi gli angle 10, qua sono un terzo. Se abbiamo tanti materiali, mettiamo un punto di virgola, definiamo una seconda riga, una terza riga, una quarta riga. In teoria si possono fare tanti materiali quanti si vogliono. Ok, definizione del materiale, e se no questa informazione da dove la prende. E poi in che unità, anche qui è un punto, dopo quando faremo qualche esempio MEMS vedremo che questa è la grande difficoltà, e devono essere coerenti innanzitutto con le dimensioni che avete usato per definire la geometria. Se avete usato il micron, queste dovranno essere l'unità micron. Ad esempio il megapascal vedremo che è una buona unità micron, perché è micro newton su micron al codato. Insomma, anch'io devo sempre andare a rivedere, però c'è sempre un set di unità di misura consistenti e coerenti che sono adatte ai problemi piccoli. Oppure se avete problemi macro, le unità SI, quindi metro, secondo, newton e così via. Le unità di misura non ci sono da nessuna parte, sono solo nella vostra testa, sono solo nel vostro foglio, che avete stabilito sul vostro foglio prima di cominciare a definire la geometria con quell'unità di misura di lunghezza e prima di assegnare le proprietà con quelle unità di misura, coerenti, consistenti fra di loro. Questo è fondamentale. Quanti errori si fanno in questa cosa? È drammatico. Poi quando ci sarà la dinamica, ci sarà l'inerzia, ci saranno tante altre cose, quando arriverà l'elettrostatica, tutti la famosa Y0 quanto vale in unità MENIS. Allora ti metti lì a fare la conversione, allora ti fai un elenco, lo salvi lì, lo tieni. E ogni volta ritorni a vederlo. Poi dopo dobbiamo associare i materiali agli elementi, quindi noi useremo questa keyword solido uguale 4 1. 4 è l'entità fisica. La superficie fisica 4 avrà il materiale 1, cioè la prima riga di materia. Poi dobbiamo mettere le condizioni al contorno, perché abbiamo imparato che per definire un problema è essenziale saper dare bene le condizioni al contorno, con quella proprietà che l'unione deve dare la delta omega all'intersezione del nulla, cioè le cose che abbiamo detto la settimana scorsa sono importantissime. Allora, abbiamo due tipi di condizioni diverse sugli spostamenti, displacement, boundary condition. La prima è su linee. N sta per nodo, la seconda su nodi precisi. Allora, questo vuol dire che io prendo l'entità fisica 1. L'entità fisica 1 è la linea 2, qua. Vi ricordate che condizione e contorno avevamo qua? Avevamo tirato con uno spostamento imposto, diverso da zero, ma uniforme su tutta la linea. Infatti ho, sull'entità fisica 1 in direzione 1, impongo lo spostamento 0,5, inventato. Sull'entità 2, fisica 2, che è la linea 4, quindi questa, cosa avevamo? che in direzione era bloccato in direzione x quindi in direzione 1 e poco 0 ok? però non erano le sole condizioni perché avevamo il carrello qua che doveva bloccare eccolo qui abbiamo il carrello qui che deve bloccare lo spostamento rigido allora usiamo questiamo quest'altra possibilità, displacement boundary conditions concentrate sui nodi, n per nodi, sul nodo 1 perché questo è il nodo 1, in direzione 2 imponiamo lo spostamento 0. Questo quindi conclude gli spostamenti imposti. E poi abbiamo invece le forze. Le forze qui sono solo, abbiamo forza 0 in direzione verticale, ma dove c'è forza zero non scriviamo niente, perché sono condizioni omogenee che spariscono dal principio delle potenze eventuali. L'unica cosa che rimangono sono le condizioni diverse da zero. Allora, traction boundary conditions sull'entità fisica 3, che è il cerchio, impongo, questa è un, io posso imporre in direzione 1, 2 o 0? 1, 2 o 0 1, 2 sono le direzioni cartesiane 0 vuol dire normale quando un matto lo troverà uno 0 qui sa che deve imporre una forza in direzione normale meno 2 cioè deve essere una pressione entrante quindi sto imponendo una pressione meno 2 su questa superficie. Queste sono le informazioni che dobbiamo fornire al nostro codice. Proviamo a farlo andare una volta, giusto per vedere che effettivamente funziona. Come si fa? All'interno della directory dove voi avete scompattato il vostro codice, troverete un file che si chiama elasticity.m. Cliccateci sopra. Vi parte MATLAB. Mi parte Mattland? Vi è partito? Si Allora, io ho una mia modo di tenere la finestra di comando MATLAB separata dall'editor. Voi avrete un differente layout, ma l'importante è saper distinguere tra la finestra di comando e invece l'editor. Allora, vi è aperto nell'editor il file elasticity. Io ce l'ho così. Per farlo andare, io lo lancio col tastino run. Vedete che qua sopra c'è questo tasto qua? Si chiama questo... Ah, c'è un delay con... eccolo. Lo vedete qua sopra. Io schiaccio run, e lui dovrebbe aprire una finestra in cui gli chiede di scegliere l'input file. Scegliete l'appendix, elasticity appendix m, apri, e lui fa l'analisi, dovrebbe avere, io ho una ho una mesh molto molto rada e quindi fa questa soluzione un po' orrenda perché ha degli elementi enormi voi probabilmente avete una mesh più fitta si si sta ancora assemblando lo fate un po' troppo è ancora il 40 e devi aprire questo post processing che è fatto anche lui in Gmesh, in cui potete scegliere, vedete qui a sinistra, fare tre cose. Avete due componenti di spostamento e i tre sforzi, xx, adesso ve lo raffiniamo perché fa veramente schifo, sigma xx, sigma yy e sigma xy. In un problema piano ci sono solamente queste tre componenti componenti adesso voglio raffinare un filo per vedere quali sono le procedure allora da fare per raffinare dobbiamo aprire il file geo io lo faccio ancora da matlab. Ok, allora quindi vado a... ho già dei parametri un pochino più raffinati, salvati. E quindi devo rilanciare Gmash con la nuova definizione di geometria è un po' noioso non è che lo farete mille volte lui rifà quindi di origine una mesh avendo discretizzato in maniera molto più raffinata adesso ho già automaticamente salvato posso chiudere Gudere Gmash. Ritorno su Rasticity, rifaccio la stessa cosa, ritengo in run, lui mi richiede, eccolo qua, scelgo sempre lo stesso file, qui a sinistra vedete che il mio computer, anche se è piccolino, è piuttosto potente, quindi va veloce. E questo è, vedete, un miglioramento anche qualitativo del campo di spostamento in direzione 1, campo di spostamento in direzione 2, sforzo, sforzo sigma yy e sigma yy. Ok? Allora, una volta uno vuole vedere la deformata. Ma come si deforma? Come si fa a costruire la deformata? Facciamo questo esercizio. Seguite le mie cose. Si va su Tools in alto. Plugins. Cliccate. E si apre questa finestra. Ci sono dei plugin che sono già stati programmati. Scorrete verso il basso la lista di plugin fino a che si arriva a Scaltovec. Scaltovec. Ok, questo è il plugin che permette di prendere due componenti e creare una componente vettoriale. È un po' elaborato, però bisogna andare qui nella finestra di destra e la view x sarà la view 0, perché vedete che Dimash ha un po' la numerazione stile c, quindi invece di partire da 1 parte da 0, quindi lo spostamento 1 è 0, 2 è 1, quindi io voglio creare un campo vettoriale usando le due componenti che stanno in 0 e 1, che sono U1 e U2. Avendo quindi definito 0 e 1 faccio run. Ok. E fa una cosa che non si capisce assolutamente con le frecce. Ha usato questo metodo di rappresentazione con le frecce, invece noi vogliamo cambiare il modo di rappresentazione. Siete arrivati? Vedete che ha creato una nuova lista, NewView5, che non esisteva, però voglio visualizzarlo un po' meglio, allora vado su Tools, Options, e modifico le opzioni della nuova vista quindi clicco su view 5 qui voglio modificare l'aspetto con cui lui me lo fa vedere il tab là in alto vado su aspect e c'è una metà c'è un vector display lui aveva questa questa 3D arrow, invece gli chiedo displacement. Vedete che già comincia a mettere il campo di spostamento invece delle arrow. Poi c'è sotto, due righe sotto, cioè displacement factor, uno è l'amplificazione che lui usa per rappresentare, uno è un po' poco perché vedete che si deve, allora mettiamo ad esempio due, vedete che già mettendo due si vede meglio la deformata, mettiamo addirittura cinque, così esagera del tutto, questa è la deformata amplificata di cinque volte. Poi questo modo di rappresentare il capo di spostamento non mi piace troppo, a me piacciono di più le isoline, ma questa è veramente una stupidaggine. Allora io vado su General in alto, sulle tab General, e vedete che c'è Intervals Type a metà, c'è Continuous preselezionato, invece io metto Field IsoValues. E lui usa 10 intervalli, se voglio aumentare il numero di intervalli vado nella riga sopra, intervall se ci scrivo ad esempio 20 e quindi migliora la rappresentazione. Questa è la deformata e il colore rappresenta il modulo dello spostamento. Ok? Quindi non si può giocare un pochettino per visualizzare nella maniera che si vuole. Ok? E questo è un po' per dirvi facilissimo giocare con questo codice, quindi per dare un senso un po' concreto a quello che stiamo facendo, però quello che adesso dobbiamo fare è prendere spunto da quello che abbiamo imparato per cominciare a sviluppare il metodo di diametri finiti ok facciamo una piccola pausa facciamo una pausa di una decina di minuti e poi continuiamo
 L'osservazione che abbiamo fatto prima, cioè che quando utilizziamo un codice che genera la mesh, quello che noi abbiamo a disposizione sono alcune informazioni che sono le posizioni dei nodi e la connettività degli elementi. L'abbiamo visto prima, è tipica la situazione. Quindi, non l'abbiamo ancora affrontato, ma lo farete se volete voi per esercizio, la lettura di quella funzione che va all'interno del file.mesh e estrae questa informazione. Viene fuori da questa lettura con alcune variabili create, alcune strutture. Le strutture che noi utilizzeremo, liste di strutture, che sono la lista dei nodi, la lista degli elementi T6, che sono gli elementi triangolari a sei nodi, e gli elementi V3, che sono gli elementi di linea a tre nodi. Cosa vuol dire? Perché dico lista di strutture? Perché ogni variabile è una struttura con più campi. Ad esempio i nodi, il nodo iesimo ha le coordinate, ha una cosa che si chiamerà degree of freedom, sono i gradi di libertà che vedremo più avanti, e avranno i valori nodali dello spostamento. Queste in blu non ci interessano adesso. Supponiamo solo che si conoscano le coordinate, perché le abbiamo lette da quel file là. Quindi ogni nodo, nodo 10, come faccio a vedere le coordinate del nodo 10? Vado in core 10, scusate, nodes10.core, e lui mi darà le due coordinate del nodo. Le ha lette, in qualche modo le ha lette. Come? Ci interessa anche abbastanza poco, però è ovvio che se c'è scritto tutto in un file, con un po' di pazienza, andiamo a leggere e risaliamo, ok? Non perdiamo troppo tempo in questo. Così come è ovvio che abbiamo potuto leggere tutte le connettità degli elementi T6, quindi se voglio sapere quali sono i sei nodi del centesimo elemento di superficie, c'entrò in T600.nodi. Nodes. E mi darò una lista di sei nodi, che sono i sei nodi che definiscono l'elemento. E così per gli elementi B3, gli elementi di linea, quelli che mi servono per imporre le condizioni al contorno e per imporre le forze, avrò una lista di tre nodi per ogni elemento B3. Questo è tutto quello che so. Quindi mi devo inventare qualcosa, no? Come faccio? Quindi ho una lista di nodi e l'elemento azzurro di superficie esiste solo nella mia testa. Non c'è scritto da nessuna parte e non è fatto. Ho solo che questo elemento avrà come nodi la connettità, mi anticipo che prima ci saranno i nodi di estremità, mi dirà 6, 47, 63 e poi mi dirà quelli di mezzo, 49, 94, 95. Saranno ordinati in questo ordine qua. Come faccio a veramente dire che questo è un elemento? Come faccio a descrivere la geometria di questo elemento? E' lo stesso per gli elementi a tre nodi, ad esempio questo potrebbe essere l'elemento 24 di linea, mi dirà che ci sono tre nodi, prima gli estremi 6, e poi i 47, poi mi dirà che per me in mezzo 49. Ma detto tutto, a partire da queste informazioni io creo la rappresentazione della geometria, creerò quelli che si chiamano gli elementi isoparametrici, che sono la classe di elementi infiniti di granuga più diffusa nella meccanica numerica. Poi ce ne sono tante altre. Gli elementi isoparametrici. Facciamo due esempi di elementi di linea, poi ne useremo uno solo e due esempi di elementi di superficie e ne useremo uno solo, sapendo, poi vedremo una carrellata grafica di tanti altri elementi, anche 3D, però ricordatevi che ci invitiamo a una classe, la classe degli elementi isoparametrici, poi spiegheremo perché il caniamo isoparametrici. Allora, supponiamo di avere un elemento a due nodi, cioè non è il caso con cui avremo a che fare, ma l'elemento B2, cioè una barra a due nodi, cioè il gm ci dice che c'è un elemento definito da due nodi, che sono i nodi di estremità. Allora avremo quelle che noi chiamiamo le coordinate nodali, x1 e x2, che sono salvate all'interno della base di dati che abbiamo visto prima. Come facciamo a descrivere la geometria segmento che congiunge x1 con x2? Ho bisogno di fare integrali, vi ricordate che dovrò fare degli integrali, quindi se devo fare un integrale per forza ho bisogno di conoscere la geometria. Allora, usiamo questo approccio. Certamente dovrò introdurre una coordinata parametrica, una coordinata parametrica che corre lungo questo segmento e che sostanzialmente parte da x1 e arriva a x2. Ciò vuol dire che noi che introduco un elemento di riferimento, che chiamerò delta, mentre questo sarà l'elemento fisico che chiamerò E, l'elemento fisico E, l'elemento di riferimento E, all'interno del quale definisco un parametro, un parametro A, che vale 0 e il mezzeria, vale meno 1 a sinistra e vale 1 a destra. Il mio parametro A. Questo elemento è un elemento di riferimento che sarà lo stesso per ogni elemento fisico di linea. Questo si chiama elemento master. Quindi creo una rappresentazione dell'elemento fisico in funzione di questo parametro. La rappresentazione più facile è dire x uguale, la trovate là sopra, una rappresentazione lineare come somma di un c0 più c1 per a. c0 e c1 sono dei vettori incogniti, c0 sono tutte due delle costanti, ma c0 rappresenterà proprio il termine costante nella rappresentazione della coordinata, C1 invece moltiplica il parametro A. Allora, come faccio a determinare C1? Impongo che X sia uguale ad X1 quando A è uguale a meno 1 e che x sia uguale a x2 quando a è uguale a più 1. Imponendo queste due condizioni ottengo questa, non lo facciamo ma è evidente che in qualche maniera riesco a rappresentare questo c0C1. Se sostituisco, allora alla fine trovo che x può essere rappresentata in questa maniera, rimaneggiando un po' i termini, è quello che mi interessa e per cui arrivo subito a questa espressione. Ok, allora x viene rappresentata come una combinazione delle due coordinate di estremo. Questa è una funzione che io chiamerò n1, funzione di a, e questa è un'altra funzione che chiamerò n1, funzione di a, e questa è un'altra funzione, che chiamerò n2, funzione di a. n1 ed n2 che aspetto hanno? Innanzitutto sono definite in funzione di a, quindi ha senso rappresentarle sull'elemento master. Sull'elemento master vado e cerco di rappresentare questa. Allora questa vale, quando a uguale a meno 1 vale 1, quindi parte da qua, e quando a vale 1 vale 0, quindi è una funzione lineare che parte da 1 e va a 0. Questa si chiama funzione di forma locale, è quella che è rappresentata nel mio slide. Se invece voglio rappresentare la seconda è un po' il laduale, perché quando a è uguale a meno 1 questaera, e quando A è uguale a 1, vale 1. Per cui è una funzione che è fatta così. N2. Questa è N2. N1 ed N2. Che proprietà hanno? Hanno delle proprietà che troveremo ricorrenti per tutti gli elementi isoparametrici, che vadano uno sul nodo di riferimento, perché N1 è naturalmente associato al primo nodo. Quindi questo lo chiameremo nodo master, molto spesso lo rappresenterò con un circolino vuoto, avremo due nodi master che sono gli estremi del segmento e poi avremo due nodi fisici che spesso rappresenterò con due pallini pieni per distinguere, nodi master e nodi fisici. Avremo sempre lo stesso numero di nodi master e nodi fisici, cioè se abbiamo due nodi fisici avremo bisogno di definire due nodi master. La funzione è tale, ogni funzione di forma è tale che vale 1 sul nodo master di riferimento e vale 0 sull'altro nodo. Quindi un nodo master sarà caratterizzato da una coordinata che io chiamerò così A1, il primo nodo master sarà caratterizzato da una coordinata A1 che in questo caso vale il meno 1, il secondo nodo master sarà caratterizzato dalla coordinata 2 che vale più 1. Come si fa a tradurre questa proprietà? In questa maniera, se io prendo la generica funzione nk e la valuto in corrispondenza di un nodo master m a m quanto vale? provate a astrarre quello che ho appena affermato se m coincide con k allora vale 1 se m diverso da k vale 0 come faccio a esprimolo? Con la famosa delta, la delta k. Questa è una proprietà che abbiamo verificato in questo esempio semplicissimo, ma che varrà tal quale per tutti gli elementi isoprametrici che creerò. E perché questa è molto importante? È molto importante perché la geometria è rappresentata esattamente nei nodi, cioè se io prendo la x e la valuto in corrispondenza di un ak, questa è la geometria in funzione di a, in funzione di a generico, ma se invece dipendono A generico, prendo il nodo master, e che cosa ottengo? A causa di questa proprietà, otterrò esattamente il nodo cappesimo. Cioè, questa rappresentazione della geometria, sembra una banalità, perché per come l'abbiamo costruita è evidente che è così. La geometria, questa è la proprietà che ti dice, ricostruzione esatta della geometria nei nodi, cioè i nodi sono sempre rappresentati in maniera esatta. Prima proprietà, questa, conseguenza immediata, il fatto che la geometria è rappresentata in maniera esatta nei nodi. Ok, questo è il nostro primo esempio, però abbiamo visto subito nel nostro caso che se vogliamo rappresentare un po' bene una curva, non un segmento diritto, questo elemento a due nodi non sarà sufficiente. Era il caso di, ricordate quando ho scritto prima Mesh 1, elementi lineari, che ha rappresentato l'arco, il cerchio, con una serie di segmenti, era orrendo. Ovviamente la geometria era mal rappresentata, allora abbiamo dovuto passare alla geometria di ordine 2 con elementi quadratici. E allora vediamo un po' che cosa sono questi elementi quadratici nel caso della linea. Nel caso della linea si chiamano elementi B3, almeno io li chiamo elementi B3, non è universale ma è abbastanza diffuso, l'elemento B3. Andiamo alla prossima slide. Allora, pensiamo sempre a Gmash. Gmash definisce un elemento B3 con tre nodi. E quindi quello che vi dà Gmash sono tre nodi fisici, che chiamerò x1, perché so che vi usa questo ordine, x2 e poi x3. Queste sono le coordinate dei tre nodi. È tutto quello che ci dà. E noi vogliamo interpolare in un certo senso la geometria passando in maniera esatta per i nodi. Prima nel segmento era evidente, questo qui comincia a diventare un po' meno evidente. Come faccio a interpolare la geometria passando esattamente per i nodi? Allora mi faccio ispirare esattamente dalla procedura che ho usato prima, la potremmo dimostrare in un altro modo, ma è veramente pedante. Allora, si utilizza l'elemento master, attenzione, un elemento master per la linea è sempre un segmentino in cui c'è un parametro che vale meno uno, che passa da meno uno a più uno. Questo lo chiamiamo sempre delta. Però siccome abbiamo tre nodi finiti, notate che il terzo nodo non è necessariamente a metà. Avrei potuto magari accentuarlo. Sta un po' dove vuole, sta dove l'ha definito G-Mesh, non lo so io dove G-Mesh l'ha messo, certamente cercherà di metterlo più vicino alla metà possibile, perché gli elementi sono fatti meglio, ma è un affare suo, lui non mi dice che è esattamente a metà, quindi non posso assumere che stia a metà, ma poi metà dove? Perché non metà sul segmento, se deve riprodurre una curva lo metterà sull'arco, da qualche parte, quindi non so niente di dove sta il terzo nodo. Allora, però so che se ho tre nodi fisici, dovrò introdurre tre nodi master, il terzo nodo master lo introduco a metà, quindi avrò un primo nodo master a 1 uguale a meno 1, un secondo nodo master a 2 uguale a più 1 e un terzo nodo master a 3 uguale a 0. Perché l'ho messo in mezzo? Perché io so che Gmesh il terzo nodo me lo mette in mezzo. Allora, ispirato da prima, esprimo, da quello che è successo prima che ha funzionato molto bene, esprimo la generica posizione in funzione di A, x in funzione di A, la coordinata fisica, come una combinazione delle tre coordinate x1, x2, x3, x1, x2, x3, moltiplicate per delle opportune funzioni di forma, che saranno diverse da quelle di prima, perché ho cambiato tipo di elemento. Quindi x2 di A, x3, n3 di A. Ok, quindi la stessa strategia di prima, una rappresentazione come prodotto delle coordinate nodali per certe funzioni di forma. E poi voglio definire queste funzioni di forma e voglio mantenere le proprietà che ho elencato prima. Cioè voglio costruire delle funzioni che in questo caso saranno quadratiche, non possono più essere lineari, che devono mantenere la stessa caratteristica di prima. Cioè se io prendo nk e la valuto in m, questa deve essere uguale a delta kn. Cioè deve valere 1 su di un nodo e sul nodo di riferimento è 0 altrume. Allora, cominciamo a costruire la prima, n1, che deve valere 1 qua e si deve annullare qui e qui. Una funzione quadratica. La quadratica certamente la posso costruire, no? Perché ho abbastanza parametri. Avrà questa forma qua. Questa sarà il n1. Ma che espressione ha? È abbastanza facile da costruire. Non ci vuole molto. Proviamo. Allora, si deve annullare. Come si fanno a costruire? So che si devono annullare in a uguale a 0 e in a uguale a più 1. Allora comincio a scrivere che dovrà valere questo. Dovrà essere proporzionale a questa cosa. Perché? Perché se a uguale a 0 si annulla. Se a uguale a 1 si annulla. Quindi ho soddisfatto il requisito che si annulli negli altri due nodi. Quello che non ho ancora soddisfatto, devo verificarmi, è che valga 1 nel primo nodo. Allora, vediamo quanto vale questa espressione in A uguale a meno 1. Allora, qui vale meno 1, qui vale 2, quindi vale meno 2, quindi cambio il segno e poi divido per 2. Questa è una funzione che rispetta esattamente la proprietà che stavo cercando. Eccola, questa, un mezzo di a per a meno 1, la prima funzione di forma. E qui ci sono le altre due, che si costruiscono esattamente nella stessa maniera. Questa è la funzione bolla, molto carina perché sta sempre positiva, che si fa con lo stesso criterio. Provate a dire voi, senza leggere lì, si deve annullare in a uguale a 1 e in a uguale a meno 1, la funzione che si annulla è 1 meno 4. 1 meno 4. E quanto vale in a uguale a 0? In a uguale a 0 vale 1, no? E quindi è a posto. Scusate, però ho fatto un errore. Non è 2 questo, perché questo è il 3. N3, perché il nodo in mezzo è il 3. 1 meno 4. E l'altra, N2, ve la lascio a voi da calcolare. Effetti semplicissimi. Basta ribaltare la prima cambiano un segno ma è la struttura la stessa un mezzo A si costruisce nella stessa maniera quindi se io conosco i tre nodi decido di interpolare la geometria in questa maniera e scriverò semplicemente d'ora in poi x uguale x funzione di a che sarà la sommatoria su i che va da 1 fino a un certo numero che è in questo caso 3 perché è l'elemento a tre nodi, di che cosa? Di ni funzione di a che moltipl x i, dove le x i sono le coordinate nodali. x i sono le coordinate nodali. Questa sarà la mia espressione dell'interpolazione della geometria per un elemento tre nodi. Cosa so? Che questa rappresentazione sarà esatta nei tre nodi. Però certamente, ad esempio, non sarà in grado di riprodurre in maniera esatta un arco di cerchio, perché è parabolica, è quadratica. Scusate, è quadratica. Quindi l'arco di cerchio non è rappresentabile con una funzione quadratica. Quindi io so a priori che fuori da questi nodi commetterò un errore. Cioè la geometria approssimata non è certamente uguale alla vera geometria. In generale, quando è che è certamente uguale? Quando il bordo è una spezzata. Se il bordo è una spezzata, uso segmenti, allora certamente riesco a rappresentarli bene. Se il bordo è quadratico, allora certamente potrò approssimarlo bene. Ma in generale faccio un errore, rappresento la geometria in maniera approssimata. Infatti, invece di parlare di ω0, ω0 è la superficie iniziale, tra un po' parlerò di ωh, cioè la geometria approssimata alla maniera degli elementi finiti. Tutti gli integrali farò su ωh, quindi sto sostituendo, sto accettando sin d'ora l'idea di sostituire la geometria reale con la geometria approssimata. Primo errore tipico degli elementi finti. Ovviamente più piccoli sono gli elementi, minore sarà questo errore. No? Ovvio. Va bene? Questo è chiaro? Va bene, sulle linee ci siamo, no? Perché le linee sono abbastanza facili. I dolori cominciano magari quando passiamo invece agli elementi di superficie. Allora l'idea è un po' la stessa, adesso la vediamo. Il triangolo è un po' più difficilino da trattare, quindi ci passiamo su un filo. Anche qui cercheremo di spiegare bene il triangolo a tre nodi e poi il triangolo a sei nodi lo costruiamo per analogia. Allora, dobbiamo rappresentare un elemento di superficie a tre nodi, quindi Gmash ci dice che c'è un elemento caratterizzato da questi tre nodi che saranno x1, x2 e x3. Io devo essere in grado di rappresentare questa superficie e per rappresentare una superficie ho bisogno non più di un solo parametro, come era nel caso di un elemento di linea, ho bisogno di due parametri. Allora decido di utilizzare un elemento master fatto così con tre nodi master due coordinate che si chiamano A1 ed A2 questo è la prima questo qui è il primo nodo ovviamente un nodo master avrà due coordinate quindi avrà un vettore questo sarà A1 che si trova in coordinate 1,0, poi avremo A2 che si trova in coordinate 0,1 e poi avremo A3 che si trova in coordinate 0,0. Ok? Quindi questo è il nodo 1, questo è il nodo 2, questo è il nodo 3. Per rappresentare un elemento di superficie ho bisogno di due parametri però torneremo all'elemento parametrico tra un istante perché prima facciamo un'operazione che ci spiega come mai le coordinate di questi parametri assumono il significato e anche la definizione di elementi coordinate di area. È la procedura che viene spiegata a pagina 36. Allora, io voglio rappresentare la posizione di un generico punto x all'interno del mio triangolo. Lo voglio rappresentare partendo da x3 e usando delle coordinate oblique. Se io traccio opportunamente questi due vettori, la somma vettoriale di questi mi porterà da x3 fino a x. E quali sono le probabilità di questi due vettori? Uno è parallelo al lato x1-x3, questo qui è proporzionale a quel lato, e il secondo è proporzionale a x2-x3, quindi io posso scrivere che x sarà uguale ad x3 più qualcosa che devo riempire che moltiplica x1-x3 più qualcosa che devo ancora riempire che moltiplica x2-x3. Perché so che questi due vettori che ho disegnato sono diretti come i due lati, che sono quelli che ho disegnato qua. Allora, questo punto che io sto prendendo in considerazione divide in maniera naturale il triangolo in tre sottotriangoli. Io chiamo A3 il triangolo che è opposto al nodo 3, A2 il triangolo che è opposto al nodo 2 e A1 l'ultimo. A1, A2 e A3 rappresentano per me allo stesso tempo anche l'area di questi triangoli. Ok? Chiaro, no? È una cosa onnivoca che posso fare. Bene. Quanto vale la somma di a1 a2 a3? E a1 a2 a1 più a2 a3, essendo una partizione nell'area del triangolo, sarà ugual ad a, area del triangolo. Va bene, allora dividiamo tutto per a. Allora, se divido tutto per a, avrò a1 diviso a più a2 diviso a più a3 diviso a uguale ad 1. Allora decido di chiamare questa coordinata a1, coordinata di area a1, questa coordinata di area A2, coordinata di area A3. Quindi ho definito questi rapporti come A1, A2 e A3. È ovvio che questi tre parametri non sono indipendenti, anzi, infatti poi ci ricondurremo a considerare come indipendenti A1 e A2 e A3 si può ricavare dei primi due come 1 meno a 1 meno a 2. Quindi è vero che abbiamo tre coordinate di area, ma non solo fra le loro indipendenti, ma anche sono legate da questa condizione che la loro somma deve essere uguale a 1. Come faccio a trovare... Provate a pensarci un secondo. Che cosa devo scrivere qui come coefficiente di proporzionalità? Proviamo a rispondere a questa domanda. Qual è il luogo dei punti che hanno la stessa coordinata a 1 di questo punto? Questo è il punto su cui mi sto focalizzando, no? C'è un luogo, a1 è questa area. Qual è il luogo dei punti che hanno la stessa identica coordinata a1? Ebbene, è la parallela a questo lato. Ok? È la parallela a questo lato. Quindi tutti i punti che si trovano su questo lato hanno la stessa identica coordinata a 1. Quindi questo punto ha la stessa coordinata a 1 di questo. E se ci pensate, a quindi è una coordinata che varia... Quanto varrà a1 in questo punto? L'area qui è 0, no? Quindi a1 varia da 0 fino a quando sarò qui, correndo lungo questo lato, varrà 1. Quindi a1 è una coordinata che varia tra 0 e 1 ed è esattamente quello che devo scrivere qua dentro. Cioè quel punto x che io ho segnato sarà caratterizzato da queste coordinate a 1, a 2, a 3 e il covincente di proporzionalità che deve essere moltiplicato per il segmento è esattamente a 1. E così pure qua sarà a 2. Allora, facendo questa semplice costruzione geometrica, adesso posso raccogliere fra di loro tutti i termini che moltiplicano x1, quelli che moltiplicano x2 e quelli che moltiplino x3 e ottengo la cosa seguente. Avrò x1 che moltiplico un x3 e ottengo la cosa seguente avrò x1 scusate x1 che moltiplica a1 poi più x2 che moltiplica a2 più x3 e x3 non c'è ancora a3 quindi non esiste però x3 moltiplica se ci fate caso 1 meno a1 meno2. E in base alla nostra definizione, questo è esattamente A3. Quindi, anche in questo caso trovo, con una costruzione completamente diversa da prima, che x è dato da x1 che moltiplica una certa funzione di forma n1. E qual è questa funzione di forma? Questa funzione di forma è semplicemente la coordinata a1, questa è a1, più x2 che moltiplica un'altra funzione di forma che si chiama n2, e se andiamo a vedere esattamente a 2, più x3 che moltiplica una terza funzione di forma n3 che è uguale alla coordinata di area 3. Qui ho dato una rappresentazione alla geometria che è identica a quella che stavo dando nel caso delle linee. È una sommatoria su i di n, i, funzione dei due parametri a 1 e a 2, che moltiplica le coordinate nodali xi. Beh, la forma è la stessa, ma vale la stessa identica proprietà che voleva prima? Cioè, è vero che queste sono funzioni di forma nel senso che dicevamo per le linee? Beh, innanzitutto la rappresentazione geometrica di queste funzioni la avete qua. Sono dei piani e si vede subito che vengono 1 nel nodo di riferimento e si annullano negli altri 2. Cioè vado la stessa identica proprietà delle altre funzioni di forma. Quindi avremmo potuto, ha un significato particolare, interpretare queste coordinate come coordinate di area, perché in molti testi vengono proprio chiamate così, proprio perché rappresentano delle aree normalizzate. Però avremmo potuto costruirle secondo lo stesso schema dell'elemento isoparametrico, cioè cercare quelle funzioni che valgono una in un nodo e si annullano negli altri. Queste tre lo soddisfano e sono le tre semplicissime coordinate di area, a 1, a 2, a 3. Attenzione, la terza non è indipendente, è funzione di a1 e a2. Quindi anche l'elemento a tre nodi si scrive nella stessa identica maniera. L'unica differenza è che ha bisogno di due parametri, a1 e a2, per essere rappresentato, perché ha un elemento di superficie. E l'elemento master è questo qua. Quindi ogni elemento fisico può essere considerato come una mappa dall'elemento master sullo spazio fisico in funzione dei due parametri A1 e A2 che definiscono l'elemento master attraverso le funzioni di forma. Una maniera un po' particolare che però ci fa capire come effettivamente il concetto di un'utilizzo di un parlamento lo vale anche in questo caso. Come prima, siccome noi useremo elementi a sei nodi, cerchiamo di estendere il concetto all'elemento T6 che effettivamente utilizzeremo in tutti i nostri codici. Allora, facciamo i soliti passaggi. Prattiamo da zero e cerchiamo di andare va. Ipotesi, il codice, il mesciatore mi assegna sei nodi. Questi sono sei nodi che chiaramente definiscono in qualche maniera un triangolo. Questi sono i nodi fisici che vengono dalla lettura del file di mesh. La numerazione è la seguente. Uno sarà il nodo 1, poi prima i nodi di vertice 2, x3, e poi noi i nodi in mezzeria, cominciando tra quello tra x1 e x2, che chiameremo x4, poi x5 e x6. Questo è convenzionale, quasi universale. Comunque Gmesh usa questa convenzione e io uso la stessa. Io voglio creare una rappresentazione della geometria che passi in maniera esatta, almeno tra i nodi. Una rappresentazione della geometria che sia esatta almeno nei nodi. Come faccio? Mi creo uno spazio parametrico di dimensione 2, perché devo rappresentare una superficie, e definisco 6 nodi master. I 6 nodi master sono i 3 vertici del triangolo e i 3 punti di mezzo, nello spazio parametrico A1, A2. Allora, definiamo bene le coordinate dei sei nodi master. Avremo il primo nodo master, che è il nodo master A1, che avrà coordinate 1, 0. Poi avremo il secondo nodo master, A2, che avrà coordinate 0,1. Il terzo nodo master avrà coordinate 0,0. E poi cominciamo con i nodi di mezzo, seguendo lo stesso ordine dell'elemento fisico. Quindi il quarto nodo master farà in mezzo, cioè il primo e il secondo. quindi avremo A4 che sta in coordinate un mezzo, un mezzo. Poi avremo A5 che sta in coordinate un zero, un mezzo. E poi avremo alla fine A6 che sta in coordinate un mezzo, zero. Questi sono i sei nodi master del nostro triangolo. Noi vogliamo che la nostra mappatura porti il primo nodo master nel primo nodo fisico, esattamente, il secondo nodo master nel secondo nodo fisico, eccetera, eccetera. Come lo scriviamo? La nostra mappa esattamente nella stessa maniera. X funzione di A sarà una sommatoria per tutti i nodi, quindi da 1 a 6, nel prodotto di opportune funzioni di forma che adesso dobbiamo identificare per le coordinate nodali. L'espressione della geometria isoparametrica ha sempre lo stesso aspetto. Quello che cambiano sono le funzioni, le funzioni di forma, ma non è difficile, non è difficile calcolarle, perché imponiamo sempre la stessa proprietà, cioè che la funzione di forma associata con un nodo valga l'I1 e si annulli su tutti gli altri nodi. Facciamo questo esercizio. Facciamo la costruzione di due funzioni di forma, una associata ad un nodo, ad esempio a 1. Allora, come si fa? Allora, lo disegno lì, mi disegno qui il nodo, l'elemento master, per dire che la mia funzione di forma deve valere 1 qua e si deve annullare in tutti gli altri cinque nodi. Allora io impongo queste, quindi come scrivo n1, vado un po' per tentativi, n1 uguale. Allora, siccome si deve annullare su questi cinque nodi, il modo più semplice è esprimere come prodotto di due rette, che sono queste che passano per i cinque nodi, la prima per i 3 e la seconda per questi due. Che equazioni hanno questa? A1 è la prima, A1 uguale a 0 è la prima retta, e questa è A1 uguale a un mezzo, quindi A1 per A1 meno un mezzo. Certamente N1 quindi si annulla su quei cinque nodi. Devo mettere a posto il covicente moltiplicativo, perché deve valere 1 sull'ultimo nodo che non ho ancora considerato. In questo nodo che ha coordinate 1,0, quanto vale questo oggetto? Vale 1 per 1 meno un mezzo, quindi vale un mezzo, dunque dovrò moltiplicarlo per 2, 2 a 1. Eccola qua. Con un po' di... è stata espressa in maniera un po' diversa, ho raccolto il 2, l'ho semplificato per il 2, quindi molto semplice da costruire, queste funzioni sono veramente banali, poi l'ho costruita una volta, e sono tabulate in tutti i testi. Costruiamo ad esempio la 4, quella che è associata a questo modo qua. Provate a farlo voi, usando lo stesso stratagemma, cioè una funzione che deve valere uno qui e si deve annullare negli altri. Ma si deve annullare in tutti questi tre, in questi qua. E allora, il trucco è moltiplicarlo di due rette, no? Tra uno a due. A uno, a due. Perché questa qui è la retta uno uguale a zero, e questa qui è la retta 2 uguale a 0. Quindi n4 sarà proporzionale a questa cosa. Poi deve valere 1 qui. Andiamo a vedere quanto vale invece questo prodotto. Lì a 1 vale un mezzo e da 2 vale un mezzo, quindi abbiamo un quarto. Allora devo moltiplicarlo per 4 per avere una funzione che vale 1. Ed è quella qua. Tutte le altre si costruiscono esattamente con lo stesso criterio. Quindi è facile, e queste sono le rappresentazioni grafiche delle funzioni, ma vedete che n1 vale 1 qui e si annulla in tutti. n4 è questa bella funzione bolla che vale 1 qua e sta nulla sugli altri nodi. Ok? E adesso usiamo queste figure per enunciare, senza assolutamente dimostrarle, per enunciare alcune proprietà, alcune proprietà che sono però fondamentali per la costruzione del metodo. Prima di rinunciare le proprietà vi faccio vedere delle altre... Ah no, vediamo, non so se ho la lista. Ecco sì, qui vedete, scusate, sono andato un po' troppo avanti perché c'è un ritardo. Non sono gli elementi che noi consideriamo, non sono gli unici, assolutamente. Solo per fare le cose relativamente semplici e non complicare troppo, allora io ho deciso di usare solo elementi triangolari di superficie e quadratici. Se no ci sono elementi quadrangolari, l'elemento quadrangolare ha quattro nodi con queste funzioni di forma che si costruiscono nella stessa maniera, ha otto nodi, quello ha nove nodi in cui si aggiunge anche un nodo in mezzo, sono infinite, infinite ricette. E poi ci sono elementi tridimensionali, questi sono i più semplici possibili, immaginabili. Sono i tetraedri a quattro nodi, che sono elementi lineari, e poi i prismi a otto nodi, che sono un po' più complessi, e poi ci sono tutte le versioni quadratiche. Il tetraedro quadratico ha dieci nodi, perché aggiungete tutti i nodi in mezzo, quindi arrivate a dieci. Il prisma può essere a diciotto, a ventisette, a seconda che si mettano tutti i nodi in mezzo e quindi arrivate a 10. Il prisma può essere a 18, a 27, a seconda che si mettano tutti i nodi anche in mezzo alle facce oppure no, infinite scelte. Quindi sappiate che i triangoli tetraedi in generale sono molto versatili per la costruzione delle meshe, ma in alcune situazioni in cui le strutture tipiche dei MEMS, in cui le strutture sono molto sottili, questi potrebbero essere troppo distorti, cioè una base larga, un'altezza molto piccola, quindi un elemento molto piatto che si chiama sliver e che si comportano molto male. E allora è meglio estrudere, se abbiamo una struttura sottile si genera una mesh nel piano e lo si estrude. Ci sono gli elementi wedge, cosiddetti wedge, che hanno una base triangolare e dei prismi nell'altra direzione. Quindi c'è un elemento per ogni applicazione e in genere i codici commerciali hanno tutta una famiglia molto ricca di elementi all'interno del quale voi potete scegliere. Quindi quello che noi vediamo nelle nostre applicazioni numeriche, ma altre avremo sempre solo T6 e B3, quando già farete le esercitazioni sul console avrete più ricchezza e potrete scegliere molti più elementi. Sabbiate che però sarete sempre limitati, almeno in questo corso, a elementi isoparametrici tutti quanti questi qua hanno le stesse identiche proprietà che in parte abbiamo già enunciato e che adesso riassumiamo per tutti prima lo voglio mostrare su queste immagini qua, per convincerevi che vedete la gente a... La prima proprietà, allora, innanzitutto lasciatemi riassumere quello che abbiamo già detto. Uno, su ogni elemento, allora, qualunque x appartenente all'elemento fisico rappresenteremo x in funzione del parametro come la sommatoria sui nodi uguale a un numero di, non lo so, n, sì, infatti non lo indico con n, perché dipende dal tipo di elemento quanti nodi ci sono, come il prodotto di n-i funzione di A che moltiplica la coordinata nodale. Prima cosa, questa è la rappresentazione della geometria. E di x, ed a, scusate, è un parametro che varia nell'elemento master. E è l'elemento fisico, quindi x vive nell'elemento fisico, A invece vive nell'elemento master parametrico. Abbiamo dei nodi fisici, X e Y, che si corrispondono con i nodi master. Cioè abbiamo definito dei nodi nell'elemento master che poi vengono mappati nei nodi dell'elemento fisico in maniera esatta, cioè che x di a k, cioè se prendo x, questa interpolazione e la valuto in corrispondenza di un nodo master ottengo esattamente xk. Questo è figlio del fatto che nk valutato nel punto m nel punto master vale delta km. Tutte queste cose valgono per ogni elemento isoparametrico. La rappresentazione, questa si chiama proprietà di rappresentazione esatta dei nodi. Ma poi c'è una struttura gerarchica negli elementi isoparametrici che discende da un'altra probabilità. Tutte queste funzioni di forma, lo vediamo graficamente senza dimostrarlo, ma lo si può dimostrare facilmente, prendiamo la prima. La funzione numero 1 è associata a questo nodo. Se prendiamo un lato che non contiene il nodo, e qui c'è solo questo lato che non contiene, perché questo lo contiene, questo lo contiene, quindi c'è solo questo lato che non contiene il nodo, la funzione di forma è zero uniformemente su tutto il lato. D'accordo? Questo vale per un elemento bidimensionale. Se avessimo un elemento tridimensionale, si annullerebbe su tutta la faccia che non contiene il nodo. Ora non semplifichiamo, non studieremo elementi tridimensionali, avremo solo di superficie. Quindi la funzione di forma si annulla su ogni lato che non contiene il nodo. Guardiamo se è vero anche su quelle di vertice, la stessa cosa, se questa è di mezzeria. Allora, questo nodo appartiene solo e esclusivamente a questo lato, non appartiene né a questo né a questo. E infatti la funzione di forma n4 che abbiamo appena calcolato si annulla in maniera identica su tutti i punti dei due lati, degli altri due lati. Questo è fondamentale perché se io voglio rappresentare la geometria di questo lato a partire dalla rappresentazione della geometria dell'elemento 2D, noi capiamo che in realtà la rappresentazione di questa geometria dipende solamente dalle tre coordinate dei nodi che giacciono su quel lato. Perché tutte le altre si annullano. Perché le altre funzioni di forma si annullano. Quindi io posso fare anche la somma su tutti i nodi, ma se un nodo non appartiene a questo lato, la sua funzione di forma sta nulla lì. Quindi la rappresentazione geometrica di questo lato dipende solo, esclusivamente, dalle tre coordinate nodali che stanno sul lato e dalle associate funzioni di forma. Quali sono le associate funzioni di forma? Sono n2, che è associata a 2, n3, che è associata a 3, ed n5, che è associato a 5. Quindi dipenderà solamente da queste tre funzioni di forma. Ma provate a restringere queste funzioni di forma sul lato. Proviamo a disegnarle. Io disegno questo lato con un segmento. Proviamo a disegnare, a immaginare questa qui, questa funzione di forma ristretta a questo lato, che aspetto ha? Ha un aspetto fatto così. Questa, no, è ancora più semplice, è fatta così. E quest'altra è fatta così. E questa è la diagia di istra. Queste sono esattamente le funzioni di forma dell'elemento B3. E in questa sta la struttura gerarchica, che un elemento di superficie la rappresentazione di un lato dipende solo e esclusivamente dalle tre coordinate nodali su quel lato. Questa avrà un'importanza drammatica, sembra una banalità ma sarà importantissima. Quindi, prima la proprietà della rappresentazione esatta dei nodi, la seconda è la gerarchia, in questo senso, e la terza proprietà, che è anche questa, è solamente importante per garantire la convergenza, è che se prendiamo un A generico, un punto dell'elemento master generico, e valutiamo tutte le funzioni di forma e facciamo la somma, resta da sempre 1, ovunque. Potete giocare, provare. Ma è così. È così per... è facilissimo andare a vedere per l'elemento di barra, questo che abbiamo calcolato da prima, no? Questa è facile, perché le due funzioni di forma sono questa e questa, se facciamo la somma otteniamo 1. Però vale per tutti, cioè anche se prendiamo l'elemento parabolico, fate la somma di questo, più questo, più questo, i covicenti quadratici vanno via, perché qui abbiamo un mezzo a quadro, qui un mezzo a quadro e qui meno a quadro, i covicenti quadrati vanno via, anche i covicenti lineari vanno via, perché qui abbiamo meno un mezzo a, quindi abbiamo più un mezzo al quadro e qui meno al quadro. I convicenti di quadrati vanno via. Anche i convicenti lineari vanno via, perché qui abbiamo meno un mezzo a, qui abbiamo più un mezzo a e qui non l'abbiamo. E rimane quindi meno un mezzo, no, qui scusate, qui niente, qui niente, e qui rimane uno. Rimane solo uno lì. Quindi è vero anche nel P3. È vero anche nel P6. È molto facile da ver verificare ricordatevi che questa proprietà garantirà la convergenza in genere garantisce la convergenza di un'analisi basata su un elemento isoparametrico e quello vale qualunque sia l'elemento ecco allora perché queste proprietà sono molto importanti? Per garantire quella che si chiama conformità della mesh. Noi non vogliamo rappresentare, ecco questa è una rappresentazione grafica di quello che si intende per conformità. La mesh è conforme se non lascia buchi e non fa apparire sovrapposizione, cioè se l'unione degli elementi dà la superficie completa ma l'intersezione degli elementi è semplicemente una linea o un punto. Cioè tutta la geometria deve essere coperta ma non ci deve essere sovrapposizione. Perché la proprietà gerarchica è fondamentale? Perché è facilissimo, grazie alla proprietà gerarchica, rispettare la conformità. Perché immaginate questi due elementi separati, e pensate a come è rappresentato il lato. La geometria di questo lato sarà un elemento isoparametrico B3, che dipende solo da queste coordinate, da queste tre coordinate sul lato. Quindi, se i due elementi separati condividono gli stessi nodi, allora rappresenteranno il lato esattamente nella stessa maniera e quindi non ci potrà essere buco, non ci potrà essere sovrapposizione. È ovvio. Cioè infatti le proprietà intrinseche degli elementi isoperamentici garantiscono a priori la conformità, a meno che uno non sia così matto da voler assegnare coordinate diverse ai nodi. Cosa che si fa in meccanica della frattura, quando si vuole simulare una frattura. Però, se volete simulare un continuo, nessuno attribuirà a questi due nodi coordinate diverse, anzi, ci sarà un solo nodo. G-Mesh vi darà lo stesso numero sia nella connettività dell'elemento E2 sia nella connettività dell'elemento E1. Troverete lo stesso numero di nodo, quindi quel nodo avrà la stessa identica coordinata, sia in un elemento sia nell'altro. Quindi la conformità della rappresentazione della geometria viene automaticamente garantita. Non c'è nessun problema in questo. Ok, e questo è... Questa è una cosa molto importante. Quindi abbiamo introdotto una famiglia di elementi, abbiamo parlato dei V2 e V3, dei T3 e dei T6, e abbiamo elencato delle proprietà senza essere troppo formali, ma che sono estremamente intuitive. E adesso quello che dobbiamo fare è introdurre, prima un concetto che distingue tra numerazione locale e globale, adesso cerchiamo di capire, e poi parlare dell'interpolazione dello spostamento, perché per adesso abbiamo parlato solo dell'interpolazione della geometria. Interpolare la geometria sarà fondamentale quando dovremo fare l'integrale, perché avremo supporto su cui integrare ma ancora non abbiamo detto niente sugli spostamenti come si rappresentano gli spostamenti le famose funzioni di forma globali, i metodi alla galerica, che cosa sono tutte queste cose qui rimangono ancora da fare
 Ricordarci qual era la... Ecco, questa cosa... Perché adesso abbiamo parlato di un elemento generico, no? E abbiamo ottenuto delle reazioni che valgono per effettivamente tutti gli elementi. E però alla fine ci dobbiamo incontrare con il fatto che all'interno di una mesh abbiamo centinaia di elementi, per cui ogni elemento sarà diverso dagli altri. In che modo? Come facciamo a dire che questo elemento è diverso da questo? Ovviamente dipenderà dalle coordinate nodali. Stiamo parlando dell'interpolazione della geometria. Quindi, come facciamo noi a dirlo? Usiamo la struttura dati che il codice crea. Ritorniamo a quello che ho detto prima. Il codice crea una lista di nodi, una lista di elementi T6 e una lista di elementi B3. Le cose che a noi interessano adesso è che la lista di nodi contiene le coordinate, di G, vabbè, questa è la dimensione geometrica, nel nostro caso sarà 2, quindi avremo due coordinate, e la lista degli elementi T6 contiene altre cose, ma in particolare contiene la connettività, cioè la lista dei sei nodi, adesso è un po' più chiara cosa sono, questi sono i sei nodi che definiscono in maniera univoco la geometria dell'elemento e anche il D3 conterrà la lista dei tre nodi. Questa è la struttura dati. Quindi, ad esempio, io dico voglio rappresentare la geometria dell'elemento 6. A un certo punto, voi vedrete che faremo un loop su tutti gli elementi, quindi partiremo dall'elemento 1 fino alla fine di tutti gli elementi, quindi a un certo punto arriviamo all'elemento 6. Vogliamo definire in maniera esatta la geometria, cioè in maniera esatta, vogliamo dire com'è rappresentata nel senso degli elementi isoparametrici la geometria dell'elemento 6. Quindi avremo un elemento fisico che in generale dipende da un indice e piccolo, ma in un altro caso diventa e6. L'elemento fisico è 6. Come è fatto? Allora avremo che x funziona di a. L'elemento master è sempre lui. L'elemento master non cambierà mai perché sarà sempre il definito dello spazio parametrico, è questo triangolino, si chiama il simplesso bidimensionale, è quello che è definito da queste coordinate. Non è quello che mi hanno definito prima, con i suoi sei elementi master. Quello che cambia invece è ilo fisico, passando da un elemento all'altro. Allora, quindi xa sarà uguale a sommatoria su i che va da 1 fino a 6, nel caso degli elementi triangolari, perché è sempre così, dn i funzione di a. E queste sono sempre le stesse, non cambia niente, indipendentemente da quale elemento, dal primo, dal centomiglionesimo, le funzioni di forma sono sempre loro. Che cos'è che cambia? Beh, l'unica cosa che può cambiare sono le coordinate nodali. Xi, però così è un po'... I vale da 1 a 6. Come faccio a distinguere fra un elemento e l'altro? Non è abbastanza significativo scrivere Xi, perché non sto dicendo quali sono le coordinate renali dell'elemento fisico. Allora io introduco un intero, che chiamo ni, ni potrebbe essere 10, 200, e quanto vale ni? Da dove lo vado a prendere? Da questo database. Ni sarà il nodo iesimo di questa connettività. X Ni. Ni è il T6, numero 6, perché sto considerando il sesto elemento fisico, entro nella sua connettività, i, l'inesimo nodo dell'elemento 6, dove i è la numerazione locale, perché i va da 1 a 6 qua, è una numerazione globale, avrà numero globale n i, nella mesh generata da gmesh. Sarà il nodo 58. Quindi associo a una numerazione locale una numerazione globale. E dove vado a beccare queste coordinate x, n, I, X, N, I saranno da cercare nella lista dei nodi. Cosa devo scrivere? Come faccio a trovare la sua coordinata? Devo andare a cercare il nodo N, I, no? Quindi prenderò la struttura N, I, punto, cor. Queste sono le coordinate di quel nodo. Ok? Quindi, rispetto a prima, che cos'è che ho cambiato? E che non lo scrivo più in questa maniera, se volete, semplice, banale, in cui usavo sempre un indice che andava da 1 a 6. Perché qui adesso devo distinguere quale elemento sto considerando, quindi devo sostituirlo con un intero, un integer ni, dove l'ni lo prendo dalla connettività degli elementi. E se hono delle coordinate, dentro nella struttura dei nodi per prenderle. Ora, non sono cose così compatte per l'aria, perché se voi entrate nel codice, facciamo un istante di pausa per dare a vedere la tipica struttura che troveremo nei nostri codici. Quando andremo a vedere il codice elasticity, quello che abbiamo lanciato prima, troveremo l'uso di queste strutture dati in continuo. Quando faremo la cosa che si chiama assemblaggio, non apre l'editor. Ci sto mettendo una vitaita da pire di brano. Questa è la Stisiti. Andiamo a vedere quello che sarà il nucleo fondamentale, poi lo spiegheremo per bene. Sarà l'assemblaggio delle matrici, la matrice di rigidezza. Si farà un loop su tutti gli elementi e a un certo punto vedete che per ogni nodo dell'elemento va a prendere il numero globale dell'elemento. L'elemento è il numero E, quindi T6E, nodes K, prende il numero globale del k-esimo nodo locale, poi costruisce una matrice, purtroppo allargherò dopo, ma è solo per dirgli che creerà una matrice che contiene coordinate nodali, che nella riga k-esima avrà le core, che nella riga k-rà le coordinate del nodo numero n. Quindi sono le operazioni, queste due, tipiche per creare la geometria dell'elemento. La matrice x che conterrà le coordinate del nodo che poi verranno passate a questa sarà la matrice, la funzione elementare che prenderà le coordinate e il materiale dell'elemento e genererà la matrice di rigidezza elementare che verrà utilizzata nell'assemblaggio, ma questo lo vedremo dopo. Quindi la struttura dati viene utilizzata in continuo ecco, quindi siamo qui siamo ritornati e dunque utilizzeremo questa rappresentazione della geometria d'ora in poi facendo riferimento alla struttura dati che abbiamo quindi diremo NDI ok? Semplicemente lo sostituirò. E aggiungerò xe per distinguere ogni elemento dall'altro, intendendo che poi vado a cercare nelle basi di dati esattamente come già ho registrato. Ok piccolo passaggio, che però è cruciale, perché stabilisce dunque una distinzione fra numerazione locale e numerazione globale. In un elemento di superficie la numerazione locale va sempre da 1 a 6, perché ci sono 6 nodi. La numerazione globale invece è la numerazione che Gmesh ha deciso per i suoi nodi. Questa è la numerazione globale dei nodi. Ad esempio per questo elemento la numerazione che Gmesha ha deciso per i suoi nodi, questa è la numerazione globale dei nodi. Ad esempio per questo elemento la numerazione globale è 647, 63, 49, 94, 95, noi da qualche parte questi numeri sono immagazzinati nella connettività dell'elemento. Quindi il concetto locale-globale è molto importante. Riuscite a seguire per adesso? Allora adesso, come detto, la geometria è bella, ma non basta la geometria, no? La geometria deve essere accompagnata a un'interpolazione degli spostamenti. Come interpoliamo gli spostamenti su di un elemento? Siccome l'elemento è isoparametrico, quindi stessa parametrizzazione, ci sono gli elementi super, gli elementi ipo, ma molto meno usati, l'elemento iso è di grande lunga più diffuso, interpoliamo lo spostamento nella stessa identica maniera. Cioè, noi diremo che se x è appartenente a E, qu'H, mettiamo il pettice H per dire che è il campo interpolato sull'elemento, funziona il parametro A, lo stesso identico che abbiamo usato per la geometria, quindi dobbiamo tenere in mente la stessa mappatura, dallo spazio parametrico allo spazio fisico, sarà espresso come sommatoria su i che va da 1 ad n e, identica prima, che usa le stesse identiche funzioni di forma, ma che moltiplica non le coordinate geometriche dei nodi, bensì quello che chiameremo lo spostamento nodale. Lo spostamento nodale. Quindi avremo dei parametri, da cui dipenderà la nostra interpolazione, che sono i valori dello spostamento nei nodi. Ah, qui va bene, c'è il k semplicemente perché non ho usato i come indice della sommatoria, ma ho usato k. Ok. Molto semplice, quasi banale. Perché mai usare una strategia diversa per interpolare lo spostamento? Però questo ci dice chiaramente già dove stiamo andando a parare che le incognite del nostro problema saranno i valori nodali dello spostamento. Quindi se abbiamo un elemento T6 ci saranno sei nodi con due componenti di spostamento incognite per nodo. Sul primo nodo, sul secondo, sul terzo. Quindi, se prendiamo un elemento T6, quanti parametri incogniti avremo? Due per nodo, perché sono le due componenti, per sei nodi, dodici. Quindi, in un elemento avremo dodici incognite, incognite, non è detto perché magari alcuni saranno imposti dalle condizioni al contorno, 12 parametri, diciamo, 12 parametri da cui l'interpolazione dello spostamento dipende. E adesso dobbiamo spiegare un po' questa notazione diversa, perché la useremo tantissimo. Perché un conto è l'espressione vettoriale di queste cose, però Matlab non le digerisce, Matlab vuole delle liste, vuole delle matrici per lavorare. Quindi anche noi adottiamo un approccio con liste e matrici, queste sono utilissime per fare tutti i passaggi che faremo, poi quando dobbiamo interloquire con Matra dobbiamo trasformare tutto in liste e matrici. Allora, per lo spostamento si fa così, introduciamo una lista che si chiama lista UH che contiene le due componenti, UH1 e UH2, che sono le due componenti perché siamo in un problema piano e quindi abbiamo due componenti dello spostamento. Noi vogliamo rappresentarlo come il prodotto di una matrice che adesso chiamiamo matrice N dell'elemento e che dopo dovremo identificare, per un vettorone che contiene tutti i parametri nodali, che sono, abbiamo detto, 12. Ordinati come? Prima mettiamo i parametri sul primo nodo, quindi avremo UN1, N1 componente 1, quindi sul primo nodo componente 1, e poi la componente 2, UN1 componente 2. Prima mettiamo i due valori sul primo nodo. Poi passiamo al secondo nodo, quindi un2 componente 1, un2 componente 2, puntini e puntini, continuiamo così, fino ad arrivare a un6 componente 1, un6 componente 2. Quindi 12 paranti. Li mettiamo in questo ordine convenzionale. L'attenzione è che non è universale, perché alcuni preferiscono mettere prima tutte le componenti 1 sui sei nodi e poi le componenti 2. Io le metto 1, 2, 1, 2, 1, 2, di nodi in nodo. Allora, come si compila questa matrice N? A partire da cosa? A partire da questa intercolazione. Cioè questa l'abbiamo fissata, abbiamo detto che useremo questa, no? Quindi, prima di tutto, l'osservazione banale è che la prima componente di U dipende solo e esclusivamente dalle prime componenti dei valori nodali. Quindi se io voglio la prima componente dovrò mettere dei coincenti che moltiplicano solamente le posizioni dispari di questo vettore, che sono la componente 1 dei vari nodi. La componente 2 dipende solo dalla componente 2 degli spostamenti nodali. Quindi nella seconda riga che esprime la componente 2 dovrò riempire i coefficienti solo nelle posizioni pari, nella posizione 2, 4, ecc. E che cosa devo mettere? Sono le funzioni di forma. Avrò quindi n1. La prima componente del netto solo nelle posizioni dispari. n1, poi metto uno zero nella seconda, nella terza posizione metto n2, nella terza metto n3, eccetera, eccetera, fino ad arrivare a n6, 0. Questa è l'interpolazione della prima componente, che moltiplica solo le posizioni dispari, quindi la componente 1, 1, eccetera. L'altra, componente 2, è esattamente la stessa cosa ma scelta di una posizione, perché devo riempire solo le posizioni pari, quindi mi trovo 0, n1, 0, n2, 0, eccetera, eccetera, fino ad arrivare a 0, n6. E questa è la cosiddetta matrice N, per cui noi diremo in maniera molto sintetica, e lo useremo tante volte anche all'interno di Matlab, che ua è uguale a n funzione di a, perché tutte queste funzioni dipendono dai parametri, che moltiplica questa lista che io in maniera sintetica chiamerò in genere U. Cioè la lista dei parametri di un elemento. Ok? L'unica cosa che dobbiamo tenere a mente è che in qualche maniera questa N viene riempita con questi coefficienti, però insomma alla fine ci si ricorda, è l'ordine di questa, con cui abbiamo compilato questa lista web, di 12 coefficienti. Ok? Guardate, una cosa dobbiamo fare attenzione che al momento noi non stiamo assolutamente distinguendo fra valori nodali che sono incogniti o che magari sono assegnati dalle condizioni al contorno. Non lo stiamo assolutamente menzionando. Qualunque siano questi parametri, noti o incogniti, vale quello che stiamo dicendo. La seconda cosa è abbastanza intuitiva, è che se io interpolo lo spostamento in questa maniera, allora varrà una relazione assolutamente simile per l'interpolazione della w. Che cosa cambia secondo voi nell'interpolazione della w? Che ha un campo di velocità, spostamento? Beh, le funzioni di forma sono sempre quelle. L'unica cosa che può cambiare sono la lista dei parametri. La lista dei parametri di elemento che chiamerò w. E cioè saranno i valori nodali della w ordinamente la stessa interpolazione. Allora, facciamo le ultime due cosuce, un quarto d'ora e venti minuti max e poi... Se vi ricordate l'espressione del principio delle potenze virtuali, il primo termine come era espresso, c'era y, quindi se vogliamo riuscire a imporre il principio delle competenze virtuali, non si può fare a meno di calcolare anche l'y, non basta avere espresso lo spostamento, bisogna essere capaci di calcolare gradiente e parte simmetrica. Quindi il nostro unico obiettivo, poi dirò solo, il 3-3-1 sostanzialmente lo saltiamo, farò solo un commento al momento della convergenza, più avanti, perché adesso sembra che abbiamo un po' estratto, stiamo facendo il 3-3-2, stress tensor per un elemento T6, ok? E dopodiché, settimana prossima, con calma, partendo da tutte queste cose che abbiamo detto che sono su di un elemento preciso, cercheremo di vedere qual è la rappresentazione globale. Ricordatevi Galerchini all'inizio, in funzione di forma globale, in quella strana funzione di... dove sono? Dove stanno nascosteoste qua dentro? Dovremo far emergere? Però questo sarà quello che faremo settimana prossima e poi cercheremo magari, se riusciamo, di fare qualche piccolo esercizio, qualche nuova, come vi diceva il modulo del MEMS, come si calcola qualche reazione, qualche esempio. Allora, allora, allora. Noi vogliamo mostrare, vogliamo arrivare a mostrare a partire da queste due relazioni che sono le cose di cui abbiamo bisogno che, allora, abbiamo detto che UH lo riscrivo per sopra è uguale ad n a n funzione di A per questa UE adesso noi vogliamo mostrare che Epsilon adesso diciamo cos'è potrà essere espresso con un'altra matrice di A che moltiplica gli stessi identici parametri nodali. Epsilon, ovviamente, intendo Epsilon valutato su QH. Cioè a partire da questo campo di spostamento, Epsilon, come faccio a calcolarlo? Cos'è Epsilon?itutto dico che y è una lista che contiene le componenti y1 1, y2 2 e 2 volte y1 2 che sono le componenti intessore delle deformazioni che abbiamo ripassato l'altro giorno ci ricordiamo come erano fatte queste cose qui sono uguali alla la prima che cos'era? era la derivata di UH1 rispetto a X1 la seconda era la derivata di UH2 rispetto a X2 e la terza invece era la somma di due termini misti, ovvero derivata di u h1 rispetto a x2 più derivata di u h2 rispetto a x1. Queste sono i tre coefficienti che vogliamo calcolare. E vogliamo mostrare che esiste una matrice B, tale che se moltiplicata per i parametri UE che sono sempre loro, sono sempre gli stessi ottengo Y ottengo Y ok? come facciamo? questo è un po' il nostro obiettivo allora vediamo un po' se c'è nella slide che ci facciamo un po' guidare, un po' di questo è quello che sentiamo, ecco, questo è, potrebbe sembrare un po' macchino, poi vediamo anche, effettivamente. Quando vedete questo carattere, vuol dire che sto copiando delle funzioni MATLAB, che poi trovate tal quale all'interno proprio delle vostre routine. Questa in particolare è la funzione che trovate all'interno della funzione centrata all'interno di T6, ad esempio aprite la funzione T6KE che calcola la matrice di rigidezza elementare, allora, ecco, questa è una matrice tutta contenuta, scusate, una funzione tutta contenuta qui, quindi con una trentina di linee, allora troverete molte delle cose qua, questa D, questa F, questa J, l'inverso di F, G e B, ecco questa è la famosa matrice B che stiamo cercando che viene effettivamente compilata qua dentro le istruzioni che adesso commenteremo poi le trovate tal quali all'interno della funzione che calcola la matrice di rigidenza per ogni elemento ma questo lo vedremo la settimana prossima queste sono alcune di quelle righe che non si vedevano bene adesso qui nella slide si vedono un po' meno allora, qual è l'input che abbiamo? l'input è la geometria dell'elemento. Cioè noi abbiamo, posso cancellare qui tanto l'obiettivo, è chiaro, poi dopo come si raggiunge è un'altra storia. E qui oltretutto metto nella stessa linea anche l'interporazione del spostamento, quh uguale a sommatorio di Ni per U Ni. Ok? Perché o meno recupero un po' di spazio qua sotto. Allora, cos'è che abbiamo in input? Abbiamo una matrice X, una matrice X che possiamo chiamare XE anche se poi per brevità chiamerò sempre XE, che è una matrice 6 per 2. Secondo voi cosa vi richiama? X e poi 6 per 2. 6 sta per numero di nodi, 2 sta per coordinate. Quindi sostanzialmente X, ritorno a x perché sono costretto a utilizzare questa, allora x, cerco di usare le stesse notazioni, k è la riga i e la colonna, quindi mi dirà qual è la coordinata del nodo k la coordinata iesima del nodo k quindi sarà x I cioè coordinata iesima e come faccio a dire il nodo k? Sarà quel nk, xnk, dove nk, vi ricorda quello che ho scritto prima, nk è uguale al t6e, perché sto prendendo in considerazione l'elemento numero e, nodi, nodes, k. E' il numero globale del k-esimo nodo. Quindi costruisco, prima di passarlo alla funzione, costruisco questa matrice che contiene per tutti e sei nodi le due coordinate. È abbastanza facile capire, l'abbiamo visto anche prima, si fa un loop sui sei nodi, si prende la connettività dell'elemento, si prende il numero globale del nodo, si va a prendere la coordinata della lista dei nodi e si riempie questa matrice con le coordinate. Quindi è una cosa che noi sappiamo fare. Lasciatemi però cancellare questo per avere un po' di spazio ok quindi X ed H ce l'abbiamo ok? senza X non si va da nessuna parte perché mi definisce la geometria. Poi, introduciamo una matrice jacobiana F. La matrice jacobiana F è tale che la sua componente IJ sia la derivata di XI, in realtà dovrei sempre scrivere HI rispetto ad AJ, però mi perdonerete se in questa procedura, che è un po' lunghetta, toglierò l'H, ovviamente intendo sempre la geometria interpolata, intanto non l'ho messa neanche qui, quindi XI rispetto ad AJ. Dove XI sono le componenti di questa interpolazione. Se ti ricordo che è una funzione di a? Certamente, perché le funzioni di forma sono funzioni di a. E poi ci sono questi. Ok, allora come faccio a calcolarlo? Sarà da là. Sarà una sommatoria, perché devo derivare questa espressione rispetto alla coordinata a j, quindi avrò una sommatoria su i che va da 1, no, scusate, devo cambiare una, perché ho chiamato i la coordinata, quindi lasciatemi fare una cosa,'indice della sommatoria lo chiamo k lo chiamo k per non confondere con con quell'indice quindi avrò la sommatoria su k che va da 1 fino a 6 poi nella derivata di nk avrò la derivata di nk rispetto ad aj, perché l'unica cosa che dipende da aj sono le funzioni di forma, che moltiplica xnk, xnk componente iesima, perché sto calcolando la derivata della coordinata iesima. Ok, quindi per riuscire ad arrivare a calcolare questa manteccia jacobiana ho bisogno di calcolare le derivate delle funzioni di forma rispetto ai parametri. Però è facile perché le funzioni di forma ce le abbiamo, no? Quindi questa derivata è una cosa che si calca una volta per tutte e sono queste. Questa matrice D è proprio riempita con le derivate delle sei funzioni di forma e quindi questa derivata la chiameremo matrice D componente KJ. Compileremo dunque una matrice D che sappiamo benissimo riempire con queste componenti. La matrice D sta quindi per derivate, derivate delle funzioni riforme. Quindi avremo che questo risulta essere uguale a D Kj per... Usiamo adesso la matrice X invece delle coordinate, no? Questa è proprio DKI. Scusate, per X, KI. DKI per X, KI. Quindi noi abbiamo ottenuto la fine, lo scrivo qui e poi dopo mettiamo il risultato finale che è fij allora vediamo se riusciamo a scrivere in forma compatta fij è uguale a dkj che moltiplica xki sì, allora qui l'ho scritto in maniera diversa, ho messo gli indici all'interno della parentesi, quindi dkj per x, ki. Come posso scrivere in un botto la relazione f uguale? f uguale per tutta la matrice, senza stare a fare distinzione fra gli indici. Evidentemente qui c'è un prodotto matrice-matrice. Il problema è che il primo indice dovrebbe avere gli indici trasposti, per cui farò semplicemente, vediamo, ci sono due modi di farlo, vediamo come lo faccio nella matrice. Si può fare così, x trasposto d. x trasposto d dà proprio l'ordine giusto degli indici ij, il primo i, poi j, e poi ottengo il prodotto matrice-matrice. Il trasporto si fa con l'apice, e quindi vedete che prima definisco, dato i valori dei parametri a 1 a 2, definisco la matrice D. E poi calcolo la matrice jacobiana come il trasporto per x trasposto per D. Quindi a questo punto ho la matrice F che contiene quindi queste derivate. Farlo matto è decisamente più facile di scriverlo qui alla lavagna. Quindi ho quella matrice lì. Basta. Cancello questo, perché tanto ormai l'abbiamo capito come si fa. La matrice F quindi è accessibile. Bene, a che mi serve questa matrice F? Mi serve perché io devo calcolare le deformazioni, quindi per arrivare a calcolare le deformazioni devo arrivare a calcolare la derivata, l'abbiamo scritto prima, devo essere capace di calcolare la derivata di Ui, vediamo, rispetto a Xj. Alla fine, per calcolare le deform deformazioni devo essere in grado di calcolare questa derivata io l'ho presa un po' alla larga perché per evitare poi di dover ritornare indietro ho cominciato a calcolare questa f che adesso ci servirà adesso dobbiamo capire perché ci serve poi è dato dovrei scrivere hi scusate hi è dato da questa espressione no? quindi anche lì che cosa può dipendere da x? e qui dipende da x a lontano c'è n che dipende da a quindi innanzitutto comincieremo a fare la regola della derivata composta quindi faremo la derivata di u hi rispetto a m per la derivata di a m rispetto a x j perché l'interporazione dipende da A non dipende da x ok? va bene quindi abbiamo problemi uno è che dobbiamo calcolare questa derivata non lo facciamo a partire da lì quindi avremo l'assommatorio su k che va da 1 a 6 della derivata dell'NI rispetto a M che moltiplica che moltiplica UNK componente I scusate questo è l'indice k perché hoato qua, ma devo cambiare l'indice di sommatoria anche qui. Tenendo lo stesso indice ci si sbaglia subito. Così come l'avevo cambiato per la geometria, l'ho cambiato anche per l'interpolazione dello spostamento. E quindi ho questo, che moltiplica la derivata di am rispetto a xj. Allora, sembra complicatissimo. In realtà ci sono tanti termini che noi abbiamo già trovato. Uno è questo, la derivata di nk rispetto ad am. Erano i coefficienti della matrice, che abbiamo sommatorio su k, del matrice che avevamo chiamato d, DKN, l'abbiamo già calcolato prima. Questo ci disturba un po' perché assomiglia molto a quello che abbiamo calcolato prima, però è l'inverso. Questi sono i coefficienti della matrice F inversa. Quindi, cosa fa? Per calcolare la matrice inversa, siccome vedete qui si calcola l'inversa di F, invece di lanciare la procedura numerica per calcolare l'inversa della matrice, la matrice 2x2 se la calcola, deve calcolare il determinante che è lo jacobiano. E poi la regoletta per calcolarsi l'inversa della matrice. Quindi così si calcola l'inversa di f. E come sottoprodotto tiene anche lo jacobiano della trasformazione che ci servirà quando poi dovremo calcolare l'integrale. J sarà lo jacobiano della trasformazione che ci servirà quando calcoleremo l'integrale. Però adesso ci interessa solo arrivare alla matrice inversa. Quindi che cos'è questo? Sarà F alla meno 1 o inv di F, componente mj, moltiplicato per l'ultima cosa che è unk, unk componente iesima, che sono i parametri dello spostamento. Allora, io introduco una matrice G, vedete, questa G che è data dal prodotto di D per l'inverso di F. Quindi io definisco la matrice G come D per F alla meno 1. E allora questo qui può essere scritto molto semplicemente come G, componente G KJ per U NK UI ok, quindi ho alla fine di tutto quanto questo processo un po' machin però ho ottenuto una rispettazione abbastanza semplice del gradiente che adesso riassumo qua. Questo gradiente dello spostamento sarà dato dalla matrice G, che so ben calcolare, là ci sono le istruzioni più semplici, più chiari dal punto di vista MATLAB, sono tre linee in croce, per noi è un pochino più complicato, per noi è molto semplice, ma lo tengo in questa maniera. Ok, un'espressione molto compatta. G, la macetina del gradiente, mi permette di calcolare tutte le componenti di questo gradiente. Quindi ho questa matrice. Che dimensioni? Beh, una domanda? No, non ve la faccio adesso. Adesso ricordatevi che quello che voglio fare è calcolare questa roba qua. Ci siamo quasi, ma manca un processo un po' tecnico. Cioè io ho le componenti, ma voglio esprimarle in questa maniera, dove vi ricordo che il B è la matrice che dobbiamo identificare, ma UE è quel vettore, è quella lista che contiene tutte le componenti nodali dello spostamento. Quindi avevamo UN1, UN1, UN2, eccetera, eccetera, fino UN6, UN6, UN2. Quindi è questo vettore UE, questo vettorone. Quindi noi dobbiamo compilare la matrice B a partire da questa relazione. L'altra cosa che ci dobbiamo ricordare è che la y conteneva tre componenti, la prima, facciamo solo la prima, il resto lo diamo per buono. Calcoliamo la prima, y uguale, prendo solo la prima, che è la derivata di uh1 rispetto a y1. Poi le altre le lasciamo come esercizio. Adesso voglio compilare questa matrice B che moltiplica lo scrivo qui Ue. Ue che è questa roba qua. Quindi devo fare un po' di sforzo perché tutto quello che mi serve è già scritto qua. Però adesso devo arrivare a compilare questa prima riga. Allora, vediamo un po'. Qui c'è una... I è l'indice dello spostamento, quindi se io voglio calcolare la derivata di 1, allora dovrò considerare solo le componenti 1, per cui avrò dei coefficienti che moltiplicano solo le posizioni dispari. Quindi ho una posizione dispari, poi certamente uno 0 e qui un coefficiente che devo mettere poi certamente uno zero e così via riempirò solo le posizioni dispari prima informazione poi, seconda cosa devo fare questa sommatoria su K qui c'è la somma, la sono persa un po' anche perché non amo le somme ma c'è sempre la sommatoria quindi per chiarezza qui dovrei mettere la sommatoria su K quindi devo sommare su tutti i nodi quindi avrò un coefficiente nella prima posizione che sarà dato da G11. Sarà G11. Poi qui avrò G21. Poi andrò avanti G31 fino ad arrivare a G610. Vediamo se effettivamente viene regita così. Eccolo lì. Questa è la creazione della della matrice B la prima riga della matrice B è fatta proprio così G1 1 0 G2 1 G3 1 e così via la seconda riga è simile perché qui avrò la derivata di UH2 rispetto a X2 e quindi sarà la stessa cosa con 0 nelle posizioni dispari e G però avrò G qui avrò un 2 e qui J però sarà la stessa identica cosa dovrebbe essere così 1, 2 infatti il 2 da dove deriva? dal fatto che sto derivando rispetto a 2 a x2 quindi J è uguale a 2 quindi J è uguale a 2 e così via. La terza riga invece è la somma un po' di queste componenti, quindi in qualche maniera riesco ad arrivare a compilare questa matrice B che mi permetterà di esprimere ogni volta che voglio la y, un po' il prodotto di B per il valore in orario. Quindi, riassunto, se voglio calcolare, sapendo che ormai sono capace, magari con un po' di difficoltà, magari andando a scopiazzare un po' la matra, epsilon la lista epsilon valutata sullo spostamento UAC come prodotto della matrice B funzione di A che è una funzione di A che moltiplica la lista dei parametri nodali UE la domanda che vi faccio è, e se invece adesso voglio calcolare y non sul campo di spostamento UH, ma sulla funzione test, perché abbiamo bisogno anche di questo, purtroppo, nel principio delle potenze virtuali. Come cambia? La definizione di y è sempre parte simmetrica del gradiente, per cui la matrice B non cambierà assolutamente, avremo la stessa identica matrice B, che dipende solo dalle funzioni di coma e dalla geometria, quello che cambierà è la lista dei parametri nodali, che quindi dovrò scrivere come un doppia E e non come U. Che è estremamente comodo, perché la B, così come prima la N, non cambia mai. Vale tal quale per la lista degli spostamenti e per la lista delle funzioni test. Per cui settimana prossima, quando faremo l'assemblaggio di tutto, cominceremo proprio con riscrivere queste relazioni qua, dando per scontato che ci ricordiamo più o meno come si ricavano le B, ma sapendo che il processo che noi abbiamo fatto si ripercuote tal quale nelle linee del nostro codicillo MATLAB che vogliamo utilizzare. Ok?
