 La settimana scorsa, si riesce a leggere qualcosa? Va bene, comunque questo è il riassunto dei metodi alla Galerkin che abbiamo introdotto all'inizio della settimana scorsa, un breve riassunto, diciamo. Quindi la soluzione viene espressa con una parte che rispetta le condizioni al contorno, estesa a tutto il dominio, per più una parte che è il prodotto di coefficienti incogniti,, le alfa e delle funzioni di forma vettoriali che sono di classe, che stanno nello spazio C, C0, di modo che globalmente questa sia sempre una funzione C in C, D, cioè che rispetta le condizioni al contorno. La W invece non ha la parte che rispetta le condizioni al contorno, perché si deve annullare dove ci sono le condizioni al contorno e la W invece non ha la parte che rispetta le condizioni al contorno perché si deve annullare dove ci sono le condizioni al contorno e contiene solamente la parte relativa alle funzioni con dei coefficienti beta diversi. I coefficienti beta sono dei coefficienti arbitrari perché definiscono il campo test e quindi le equazioni che otterremo verranno imposte per tutti i possibili valori di beta. E poi abbiamo preso questa espansione e le abbiamo messe all'interno del nostro principio delle potenze virtuali. Dopo ritorneremo un filo su 1,3, però ricordo che questa è l'espressione che oggi useremo tanto, Epsilon è la Epsilon valutata sulla soluzione numerica che stiamo cercando, contratta con a, questo genera sigma, sigma valutato sulla soluzione numerica, doppiamente contratto con y. Ecco, su questo volevo ritornare un secondo, perché forse non ho insistito molto, avevo detto rapidamente che cos'è quel doppio punto, quei due punti. Quando io scrivo sigma contratto con y, questo con gli indici si deve leggere sigma ij per yj. Ci sono due indici ripetuti, quindi devono essere sommati. Facciamo il caso che poi noi utilizzeremo alla lezione, il caso piano, quindi gli indici vanno da 1 a 2, il caso di plane strain, adesso abbiamo anche messo la definizione di plane strain corretta alla fine del capitolo 2, però sostanzialmente quando è che si applica questa idealizzazione? Quando abbiamo un corpo estruso molto molto lungo, come può essere una galleria, come può essere una diga, e allora è estremamente ragionevole ipotizzare che lo spostamento u z è uguale a 0, cioè non ci sia spostamento in direzione z e che tutte le altre componenti ux e uy siano funzioni solamente di x e y. Questo è un problema piano perché la z sparisce sostanzialmente. Il codice che vedremo è in deformazioni piane. Poi c'è l'altra alternativa per ridurre un problema piano che si chiama sforzo piano, in cui è il caso delle strutture molto sottili, in cui si quotizza non che Z sia uguale a 0, ma che sigma ZZ sia uguale a 0, come il caso dei gusci, delle piastre molto sottili. Dal punto di vista del codice, dell'implementazione di ambienti finiti, la differenza tra Planes Trane e Planes Trane si riduce solo a cambiare la matrice di rigidezza all'interno del codice. Niente di più. Siccome è un dettaglio, io l'ho fatto solo per il plane strain. Ma vediamo. Quali sono le Y? Per capire quello che faremo, perché non parleremo mai di Z. Come mai? Perché se provate a calcolare i componenti di Y, tutto ciò che dipende da Z qui sparisce. Non c'è un z, non dipendono da z, quindi le componenti y, y, y, y, y, z e chiaramente y, z, z sono tutte uguali a zero. Evidentemente. Per cui le uniche componenti diverse da zero ai, sono le componenti in cui appaiono gli indici x e y. Quindi le uniche tre componenti diverse da zero sono quelle lì. Per questo noi abbiamo creato, alla fine della settimana scorsa, questa lista y, vi ricordate, che è molto comoda per lavorare con Matlab, che contiene le componenti, queste tre componenti, con l'unica differenza che mettiamo un 2 davanti all'y e y. Adesso cerchiamo di spiegare il perché dei 2, in relazione a questo prodotto doppiamente, si dice prodotto doppiamente contratto. Applichiamolo al caso di plane strain, in cui molte delle componenti sono uguali a zero. Allora bisogna sommare sui j, quindi cominciamo a scrivere stigma xx, yx, cominciamo poi a mettere tutte le componenti con gli indici uguali, avremo sigma yy per yyy, zz non c'è perché yzz è uguale a 0, e poi abbiamo le somme con gli indici diversi, quindi avremo sigma xy per yxy, più però gli indici anche trascosti, sigma yx per yyx. Ma per la simmetria di tutti questi tensori, questi due termini sono uguali fra di loro. Per cui non lo scriveremo mai così, ma metteremo semplicemente un 2 davanti al primo termine e cancelleremo il secondo. Attenzione, vedete che in questa sommatoria, molto semplice alla fine in 2D, perché contiene solo questi tre termini, non appare sigmazz, ma sigmazz non è in generale uguale a zero, perché se dovete garantire che il corpo non si muova in direzione z, ci sarà anche un sigmazz. Ma non è indipendente dal resto e non appare qui perché è moltiplicato per un yzz che è nullo. Quindi se vogliamo semplicemente calcolare questo prodotto ovviamente con un tratto che poi è il termine che appare qua, allora noi definiamo la sigma che contiene le tre componenti che ci interessano, sigma xx, sigma yy, sigma xy e con questa y vedete che se faccio sigma trasposto y ottengo esattamente sigma yy e proprio per il fatto che vi abbiamo messo un 2 quindi Quindi questo 2 ha molti significati, ma in particolare ci esemplifica la vita, perché permette di esprimere questa strana cosa che è il prodotto doppiamente contratto, come semplicemente il prodotto di una lista trasposta per la lista Y. Ok? Ma finiamo questa cosa qui, così dopo non la riprenderemo più. Sigma dipende da y attraverso il legame costitutivo, perché sappiamo, vi ricordate il legame costitutivo che sigma, per il caso in isotropo, affermava che sigma è uguale alla traccia di epsilon per 1 più 2 mu per epsilon. Questo era il legame costitutivo isotropo che abbiamo detto che avremmo utilizzato sempre. Come diventa nel nostro caso? Ci interessano le tre componenti di sigma? Sigma apparirà solamente in questo termine perché da nessun'altra parte appare sigma nel principio delle potenze virtuali. Quindi ci limitiamo solo ad esprimere questa lista sigma che contiene tre componenti e in generale possiamo benissimo dire che questo sarà dato da una matrice che moltiplica y, da una matrice 3x3 che moltiplica y. E com'è fatta? La matrice A si deduce da questo legame, perché ad esempio sigma xx, lo prendo da qua, sarà uguale a che cosa? L'anda per la traccia di y, la traccia di y è la somma degli indici uguali, quindi avremo lambda per y xx più y y y, poi 1, in questo caso questo tensore vale 1 perché stiamo valutando sigma xx, e poi abbiamo 2 mu e yxx. Quindi la matrice A, in questo caso, e sappiamo compilare la prima riga grazie a questo, allora il primo termine, quello che moltiplica yxx, sarà lambda più 2 mu. Poi il secondo termine, quello che moltiplica yy, sarà lambda e poi il termine che moltiplica la terza componente di y, quella con indici diversi, è zero. E così, se potete compilare le altre, potete benissimo compilare le altre righe, con stensierato la simmetria di tutto quello che c'è, la struttura risulterà essere questa. Potete andare a guardare. Scusate, facciamo un errore, perché non consideravo il 2. Visto che c'è il 2 nella y, più c'è solo metterla 1. Perché c'è due volte y, ricordate che c'è due volte, è finito, lo ho cancellato. C'è la due volte y, c'è due volte, quindi se volete, per il nostro problema, per essere il legame costituttivo, si riduce a questa matrice, quando diremo legame costituttivo, per noi sarà quella matrice, una matrice un po' diversa, e poi, ecco, vi faccio vedere vedere subito dove la trovate questa matrice, ad esempio nel codice, la trovate nelle routine che calcolano, che adesso analizzeremo, che calcano la matrice di rigidezza elementare, spiegheremo che cos'è. Adesso aspettiamo che si apra. Ci sta mettendo un po' di tempo per aprire il reddito. Non è ancora finito. Forse perché devo andare a cercare la licenza quando mi sono collegato alla mia reddito. Eccolo qua, salterà fuori. Vedete, ha un aspetto all'inizio della routine, si definisce proprio A, e voi direte, va bene, ma è diversa. No, perché se poi andate a vedere quali sono le espressioni di lambda e mu in funzione del modulo di Young e del coefficiente in Poisson, vi vengono fuori queste cose qua. Vi vengono fuori queste. Dopo la analizzereeremo per bene, anzi faccio già il sforzo di aumentare la dimensione del carattere così dopo potremo guardare meglio. Ma è già applicato? Ma è piccolino così. Si legge? Si, si, magari è che si legge abbastanza. Lo vediamo. Allora, quindi questo mi premeva per mettere a posto un po' di cose, poi, ok, un metro alla galleria che è inizio della volta scorsa, avevamo ipotizzato questa forma, l'avevamo sbattuto all'interno del principio delle potenze eventuali e era venuto fuori il sistema lineare da risolvere. Abbiamo detto che il metodo di elementi finiti è un metodo della Galerkin che permette di risolvere tanti piccoli problemi che abbiamo potuto intuire. Il primo problema che dovremmo spiegare come viene risolto è la costruzione di questa parte Ud, cioè come si crea una funzione che rispetta le condizioni al contorno e che viene stesa su tutto il dominio. Non è banale se la geometria non è banale. Il secondo problema è come vengono scelte le funzioni di forma. Anche queste, le classi C0. Abbiamo cominciato un po' a vedere, ma è una cosa molto lontana ancora, perché non sono funzioni di forma definite su tutto il dominio, quello che abbiamo visto la volta scorsa, abbiamo lavorato sull'elemento, quindi ci manca un po'. Poi, come faremo a valutare questi integrali? Questa Kij, il coefficiente Kij è definito, una volta nota la funzione di forma, bisogna valutare l'epsilon, integrare, come si fa se la geometria è complessa? Anche questo problema verrà risolto dal metodo di elementi finiti. La soluzione del sistema invece verrà fatta, secondo le tecniche di analisi numerica, una qualunque decomposizione della matrice. Quindi oggi dobbiamo fare questo. Vi ricordate, facciamo il rapidissimo riassunto, abbiamo introdotto gli elementi isoparametrici, prima quelli di linea a due nodi, poi quelli a tre nodi, poi siamo passati dalla superficie agli elementi triangolari a tre nodi lineari, gli elementi triangolari a sei nodi e alla fine siamo arrivati a esprimere il campo di questo garantiva la conformità, abbiamo raccontato che è facile riempire tutto il dominio, evitare sovrapposizioni con questi elementi che sono gerarchici, hanno una struttura gerarchica, ok? E poi siamo arrivati a dire, perché sono altri esempi, abbiamo discusso la generazione di questa cosa, ecco, qui siamo arrivati a dire due cose alla fine della lezione. La prima è... Non si legge l'eonica tanto. Ma sì. Vabbè, comunque, su ogni... Adesso stiamo realizzando un singolo elemento isoparametrico. Quindi stiamo affrontando un problema locale. Poi avremo il problema di estenderlo al problema globale. Quindi adesso stiamo esaminando un singolo elemento parametrico, l'interpolazione scusate prima, cioè l'interpolazione della geometria che ho saltato evidentemente, eccola qui, sì, c'è l'interpolazione della geometria, cioè su ogni elemento la geometria x funziona delle coordinate parametriche, A, cioè ci si riferisce sempre a un elemento parametrico, che è il simplesso bidimensionale in questo caso, e la geometria viene rappresentata come la sommatoria delle funzioni di forma moltiplicata per le coordinate nodali, dove questo nk indica un intero, un intero che dipende dall'indice k, sto facendo la sommatoria su k, e questa è la connettività dell'elemento, dove si trovano questi numeri globali dei nodi che caratterizzano l'elemento in questa struttura dati. Per l'elemento t6 numero e si entra nel campo nodi, posizione K, e questo è il numero globale del k-esimo nodo locale. Distinzione tra numerazione locale, che varia sempre da 1 a 6, e numerazione globale, che invece è quella che viene assegnata dal codice e che è rappresentata in maniera, senza un significato particolare qui nel disegno. Questa è la geometria, questa è la presentazione della geometria, lo spostamento viene rappresentato esattamente con lo stesso criterio, cioè lo spostamento a cui metto un pdc-h per indicare che è uno spostamento interpolato nel senso degli elementi finiti, sarà dato dalla sommatoria delle stesse identiche funzioni di forma per i valori nodali dello spostamento, che sono dei vettori. Perché? Proviamo magari questo, lo posso certamente togliere, ecco diventa un po' più grosso, magari si vede un po' meglio, gli spostamenti nod, che sono dei vettori, perché ognuno ha la prima componente e la seconda componente. Quindi, se voglio la prima componente di OH, interpolerò le prime componenti degli spostamenti nodali, se voglio la seconda, interpolerò le seconde. E allora noi li abbiamo posto, alla fine, in questa forma, che ci sarà tanto utile. Lista U, che contiene le due componenti, sarà matrice N per la lista UE. Dobbiamo fare questo sforzo oggi, di memorizzare alcune cose, questa e una di quelle, come è fatta la lista UE. La lista UE contiene, per un elemento di 6, le 12 componenti nodali. Per il primo nodo, per il secondo nodo, terzo, quarto, quinto, sesto. Quindi è una lista di 12 componenti. Se fossimo in 3D, avremmo 6 per 3, 18. Siamo in 2D, quindi siamo 6 per 2, 6 nodi, 2 componenti. E la matrice N, va bene, l'abbiamo fatto lo sforzo di immaginarla, è codificata all'interno dei nostri quadricilli, ma ha sempre questa forma qui, non ci servirà più in questo momento ricordarlo come è fatta. A noi basta ricordareare questa cosa qua. Na è una matrice che funziona delle coordinate parametriche, due, perché saranno nessuna superficie, quindi due coordinate parametriche, per la lista dei valori nodali, dodici. Dodici valori nodali. E qui ovviamente se invece di interpolare uno spostamento voglio interpolare la funzione test, le funzioni di forma sono esamente le stesse la matrice sarà la stessa cambierà la lista dei valori nodali che chiamo WI ok? allora attenzione questo oggi sarà molto importante la settimana scorsa almeno anche se l'avevo già anticipato qui stiamo analizzando un elemento e non stiamo facendo assolutamente distinzione fra quei valori nodali che sono assegnati o sono incogniti. Quando poi passeremo al problema globale, la grossa difficoltà sarà riuscire a distinguere quali di questi valori sono delle incognite e quali invece sono imposti dalle condizioni al contorno. Quindi dovremo sviluppare una strategia, e questa si chiamerà proprio assemblaggio, per effettivamente distinguere bene queste cose. Ok? Quindi questo lo memorizziamo bene, ce lo mettiamo lì, e poi abbiamo fatto un ulteriore passo, molto importante, abbastanza complicato, ma molto più complicato a spiegare che a codificarlo. I codificati sono quattro righe. A spiegare ci abbiamo messo un po'. La fine è sempre questa. La fine è epsilon, la lista epsilon, cioè di quelle tre componenti, yxx, y e 2xxy, è data dal prodotto di una matrice che chiamiamo B invece che n, funzione delle coordinate parametriche, che moltiplica la lista dei valori nodali UE. Ok? E se volessimo invece calcolare Y su qualunque altro campo, ad esempio sul campo W, cioè la parte semetrica del gradiente W, cosa cambierebbe? La matrice BA dipende solo dalla geometria, quella rimane uguale. Cambia la lista dei valori nodali, W. Lo chiameremo W quando dovremo metterlo là dentro. Va bene, non ci dobbiamo preoccupare di questo perché una volta chiarito è sempre quello di contiene le derivate. Ecco, la cosa importante che teniamo a mente è che J è il determinante di quella matrice, la matrice F, che è la matrice jacobiana della trasformazione fra l'elemento parametrico e l'elemento fisico. Ed è lo jacobiano che apparirà quando faremo gli integrali. Perché per fare un integrale sull'elemento fisico, mapperemo indietro sull'elemento parametrico e apparirà quindi questo jacobiano. E avremo bisogno proprio di questa quantità che abbiamo però già a disposizione, perché l'abbiamo già calcolata per arrivare a fare il gradiente. Quindi la stessa cosa ci servirà. Va bene, questo è magari, vi siete un po' dimenticati come si fa, prima o poi bisognerà entrare dentro, magari facendo qualche esercizio, ma ci ricordiamo quindi, ε uguale b per u, u uguale n per u. Se cambio il campo, cambia solo la lista dei valori nodali. E non ho fatto nessuna distinzione tra valori assegnati, i valori... Ecco, i b, abbiamo provato a costruire una riga di b, no? E semplicemente mettersi lì e provare a immaginare, data il gradiente, quanto vale b. Ok, allora, qui trovate un po' il riassunto di queste cose qua, però applicato al provo a arrumare un filo, vediamo... ho fatto in 16 nonni pensando che fosse meglio ma probabilmente era meglio tenere i 4 terzi perché questo schermo è più 4 terzi che altro... però lo schermo in proiezione sembra tanto 16-9. Va bene, possiamo stare. Cerchiamo di sopravvivere. Questo è uno snapshot delle dispense, tanto per dire. Quindi, veramente, se perdete qualcosa, andate lì, leggete, poi se non lo capite mi chiedete. Allora, riassunto delle cose fatte finora. Epsilon uguale B per U. Se valuto Epsilon su H sarà dato da B per UE, la lista dei valori nodali UE. Se valuto Epsilon su W avrò B per WE, la lista dei valori nodali di W. Ok? Benissimo. Poi, quello che ho scritto prima, senza spiegarlo, qui è scritto senza spiegarlo, sigma uguale a per y, è quello che ho ricordato prima, dove a è proprio questa matrice qui, vi trovate proprio la matrice. Questo è il nostro legame costitutivo. È la stessa cosa che dicevo prima, sigma 3,3, sigma z,z è diverso da zero in generale, ma siccome non appare nel prodotto doppiamente contratto, non appare mai neanche all'interno del legame costitutivo. Bene. Allora adesso cosa dobbiamo fare? Siccome dobbiamo imporre il principio delle potenze virtuali come l'abbiamo scritto prima, dovremo valutare questo termine qua, y valutato su uh, contratto con A, e questo è sigma, come vi ho detto prima, contratto con epsilon valutato su W, la forma debole dell'equilibrio. Bene, allora qui si usano tutte le simmetrie per ribaltare, io scrivo prima epsilon su W moltiplicato per sigma, perché più normale allora partiamo da questo punto e utilizziamo le cose che sono state fatte sinora il mio obiettivo di questa prima parte della lezione è arrivare a valutare quell'integrale lì quindi come si fa? rispondere quindi a una delle difficoltà nel metodo della galetta e come si fa ad autonomi l'integrale? Allora io lo sto rotitando l'integrale sull'elemento fisico di questa cosa che ormai ho già modificato l'ordine e la chiamo sigma u h però ho mostrato integrata integrata su volume però io ho appena mostrato che questo prodotto doppiamente contratto era uguale a y trasposto contratto con sigma e y trasposto contratto con, epsilon, scusate, devo mettere valutato su che cosa? Perché epsilon è valutato su W. Trasposto, contratto con la lista sigma. Ma sigma abbiamo detto che è A per epsilon. Quindi avremo per A per epsilon, lista epsilon, valutata sulla soluzione elementi finiti che stiamo cercando in di omega. Ok? Questo è semplicemente il passaggio dalla notazione tensoriale alla notazione con le liste, giustificato da quello che abbiamo fatto qui. Adesso utilizziamo queste relazioni qua sopra, che le epsilon sono su due elementi isoparametrici espresse in questa forma. E lo inseriamo qua. E osserviamo che i valori, i parametri nodali, che siano UE o WEE, sono delle costanti sull'elemento, quindi possono essere portate fuori dall'integrale. E quindi avremo che ci sarà una Wae trasposto per l'integrale su ω di B valutato su A trasposto per A per B valutato su A di omega tutto questo fra parentesi moltiplicato per la lista UE moltiplicato per la lista UE ho semplicemente sostituito e fatto i trasporti ecco questo è il se io so che sono capace di valutare questo integrale, questo che ho messo fra parentesi genera una matrice, una matrice di che dimensioni? E' premoltiplica una cosa di 12 e moltiplica una cosa di 12, quindi 12 per 12. E la chiameremo matrice di rigidezza elementare, una matrice di rigidezza elementare di dimensioni 12x12. Però se sono capace di calcolarla. Prima la devo calcolarla, prima di dargli un nome la devo calcolarla. Però la cosa interessante è che dipende solo dalla geometria dell'elemento. Non avete bisogno di nessun'altra informazione perché tutti i valori nodali sono fuori. I valori nodali sono portati fuori. Quindi i valori nodali non li conosco ancora, chiaramente. I valori VW sono i valori arbitrari che imporro dopo. Ue non li conosco ma non mi interessa niente perché tanto sono fuori. L'integrale non posso benissimo valutare perché dipende solo e esclusivamente dalla geometria. Allora, va bene, io voglio valutare questo integrale. Notate che il primo passaggio è chiaramente quello che avevo anticipato prima, mappo l'elemento fisico sull'elemento isoparametrico. Quindi invece di avere quella roba lì avrò l'integrale sull'elemento di riferimento che nel nostro caso è il triangolo, ricordate quel triangolo sempre uguale, il simplesso in 2D, B, trasposto A per B, poi quando devo esprimere di omega, qui avrò lo Iacobiano, lo Iacobiano, proprio quello che citavo prima, che sarà funzione delle coordinate parametriche, in DA1, DA2. Cioè, devo essere, forse anche meglio, ma sì, poi ci saranno tutti dei limiti di integrazione, ma perché questo è un triangolo, quindi bisogna stare attenti ai limiti di integrazione. Allora, è facile o è difficile valutare questo integrale? La vediamo un po'. B è noto, B è noto, l'abbiamo calcolato, però non è un'espressione in generale polinomiale, perché ha... andiamo a vedere come l'abbiamo calcolato... era funzione delle componenti del gradiente. E, ahimè, il gradiente dipende dai falamero 1. Il falamero 1 contiene lo jacobiano denominatore. Quindi non è una funzione razionale in generale, cioè non è un polinomio semplicemente, ma denominatore è il terminato che è un'espressione cubica. Non è un'espressione polinomiata. E così non solo, scusate questo termine che appare qui, ma anche quest'altro. In generale, valutare analiticamente queste integrali può essere molto complicato. E comunque con gli orienti finiti si adotta un approccio molto problematico e si sostituisce ogni integrazione con un'integrazione numerica. Non so se voi avete studiato un po' l'integrazione numerica. In due parole. Integrazione di Gauss. L'avete fatto un corso di analisi numerica, no? Sì, però sono forse un caso a parte. Ok, comunque, due parole. Perché il concetto è semplicplicissimo il difficile è trovare quelli che si chiamano i punti di Gauss ma l'ha fatto Gauss, quindi di noi non ci preoccupiamo se vogliamo calcolare un integrale se vogliamo no, questo sono andato troppo avanti scusate, lo slide prima forse no, qui ho sbagliato a ho sbagliato a copiare la formula scusate, ho fatto un pasticcio nello scheru qui alla lavagna la cosa più semplice è quando dobbiamo calcolare un integrale di linea. Dobbiamo calcolare un integrale su una linea da x1 a x2, facciamo così, da a1 ad a2 di f di a. Questa è la cosa più semplice. Non si fa l'integrale analitico ma ci sono dei punti di Gauss particolari che permettono di trasformare questo in una sommatoria, cioè si somma sul numero di punti di Gauss scelti la funzione valutata in un particolare punto che si chiama punto di Gauss moltiplicata per un peso. Quindi Ag è l'ascissa di Gauss e W è un peso. E W è un peso. Dappertutto trovate tabulati quali sono i punti di Gauss e i pesi e associato l'accuratezza della formula. Vi spiego. Ad esempio, prendiamo il caso più semplice, un punto di Gauss. Supponiamo per semplicare di fare l'integrale tra meno 1 e 1, cioè che gli estremi di integrazione siano meno 1 e 1, perché sennò dovete fare un'ulteriore trasformazione prima di arrivare a questo punto. Avete tutto nell'appendice e tutte queste cose qui ci sono. Allora, il primo caso. Abbiamo un solo punto di Gauss che è il punto di mezzo. Quindi valutiamo la funzione in 0 e la moltiplichiamo per 2. Quindi il primo caso brutale è 2FA, f di 0. Facciamo la media, sostanzialmente. La prendiamo nel punto di mezzo, la lunghezza del segmento è 2 perché va da meno 1 a 2, quindi prendiamo valutata in mezzo e la moltipliciamo per 2. Questo ci permette di calcolare con esattezza un polinomio di ordine 1. Questo P è l'ordine del polinomio che riusciamo ad integrare in maniera esatta utilizzando la specifica regola di Gauss. Quindi se uso la regola di Gauss con un punto riesco a valutare in maniera corretta un polinomio lineare. No, perché prendo valore medio proprio. Se F è un'espressione lineare, a metà prendo valore medio e ci azzecco. In generale per noi non è mai sufficiente e utilizziamo ad esempio almeno le regole con due punti di Gauss, dove le ascisse sono queste qui. Cioè noi prendiamo il nostro segmento da meno 1 a 1 e abbiamo due punti, qui manca un più o meno perché sono i due punti meno e più questo valore che poi è legato alla radice di 3 e i pesi di ciascuno di questi due punti sono 1, quindi noi valuteremo in integrale scegliendo questa regola di Gauss così come f di a1 per 1, perché il peso è 1, più f di a2 per 1, dove a1 e a2 sono più o meno quello 0,57 rotti. Sembra una regola barattissima, ma vi permette di calcolare in maniera esatta l'integrale di un polinomio di ordine 3. La regola è che se utilizzate un'integrazione di Gauss con n punti, riuscite a integrare il polinomio di ordine 2n-1. Quindi molto potente. Se ad esempio integrate con una regola tre punti, dove un punto di mezzo è in zero e questi sono più o meno, e usate questi pesi, riuscite a integrare correttamente un polinomio di ordine 5. Questo è un risultato stranoto per gli integrali monodimensionali. Però per nostra fortuna questo è stato sviluppato anche per gli integrali a più dimensioni, anche per i triangoli. Quando noi dobbiamo fare gli integrali su di un elemento parametrico a forma di triangolo, che è esattamente il nostro caso, ci sono delle formule equivalenti. Ad esempio, guardiamo la prima. Dobbiamo fare, quindi, ricordatevi che noi facciamo, è il nostro caso, dobbiamo fare un integrale su di un elemento triangolare di questo genere. Questo è A1, questo è A2, questo è l'elemento parametrico che viene mappato sull'elemento fisico. Quindi noi abbiamo, prima di tutto, espresso tutti gli integrali in funzione delle coordinate parametriche. E dobbiamo effettuare l'integrale numerico all'interno dello spazio parametrico. Decidiamo di utilizzare la prima regola. La prima regola di Gauss, la più banale, non la useremo mai. Un solo punto di Gauss. La prima coordinata va in un terzo e la seconda va in un terzo. Cioè stiamo solitamente ponendoci nel baricentro del nostro triangolino, da qualche parte qua. E stiamo utilizzando come peso 0,5. Perché 0,5? Perché l'area di questo triangolo è un mezzo e quindi il peso deve essere 0,5. Questo permette di integrare in maniera esatta un polinomio in A1 e A2 di ordine 1, cioè un polinomio lineare. Stesso criterio di prima, P indica l'ordine del polinomio, questa volta in funzione di A1 e A2, che può essere integrato in maniera esatta usando quella regola. Quindi se utilizzeremo una regola con tre punti di Gauss, potremo integrare correttamente un polinomio di ordine 2. E andiamo avanti. Ci vogliono più punti che nel caso monodimensionale perché è più complesso, però capite che andando sufficientemente avanti potremo integrare delle funzioni anche piuttosto complesse e con ottima accuratezza. Ora nel metodo di elementi finiti nessuno si pone problemi e tutti usano solo e esclusivamente l'integrale numerico. E credetemi, tra tutte le approssimazioni che si fanno, questa è assolutamente trascurabile. Il problema è come scegliamo l'ordine, con che criterio. Ne abbiamo tante di regole, quindi come si sceglie l'ordine della regola di Gauss? È una cosa che vi racconto senza troppo giustificarla, ma è abbastanza intuitiva. Allora, suppongo che lo jacobiano, e sono cancellato, ma c'era lo jacobiano, suppongo che lo jacobiano sia una costante. Più piccoli sono gli elementi e più questo sarà vero. Se lo jacobiano è una costante, allora quando faccio l'inversa di f a denominatore c'è una costante, non mi dà problemi. Allora riesco a mostrare che quello che devo integrare è un polinomio, effettivamente. E che polinomio sarà? Se lo jacobiano è una costante, che polinomio avrò effettivamente? Devo determinare l'ordine di questa cosa che devo integrare. Allora, A è una matrice di costanti, J abbiamo detto che è lo jacobiano per ipotesi costante, quindi mi rimane da chiedermi che polinomio è B. Ma B contiene le derivate delle funzioni di forma erano quadratiche le funzioni di forma erano quadratiche e queste derivate diventano lineari quindi B è una funzione lineare delle due coordinate parametriche o due volte B quindi alla fine ho un polinomio di ordine 2 ed è per questo che nella stragrande maggioranza delle routine che voi troverete utilizzeremo una regola a tre punti di Gauss. E dove li troveremo questi punti di Gauss? Andiamo a vedere, no? Perché sembrano cose un po' strampalate, ma poi alla fine è facilissimo metterle in opera. La cosa difficile è dimostrare che valgono tutte queste cose che vi sto dicendo. Allora, ritorniamo sempre al caso della matrice, poi la riguarderemo meglio, no? Vedete, la prima cosa che si definisce è la matrice A, che contiene le costanti elastiche, questa qui. Poi vedete che qua sotto io definisco subito le ascienze di Gauss, che hanno tre righe, tre righe, e quindi tre punti di Gauss, quella che dà un'accuratezza di ordine 2. E questi sono i pesi, un sesto, un sesto, un sesto. Voi forse vi chiederete, ma perché ogni riga ha tre numeri invece che due? Visto che sto integrando su due nostri artigianici. Per comodità, solo per comodità, ho anche aggiunto quella che la volta scorsa abbiamo chiamato la terza coordinata di area, che non è indipendente dalle altre. Vi ricordate la 3, la coordinata di area, era quella che ha aggiunto le altre due da 1. Quindi è una conseguenza immediata. Infatti vedete che la somma, abbiamo un sesto e la somma da sempre sei. Per cui la terza, se volete, è totalmente inutile, ma per comodità e per velocità la si mette dentro. Quindi all'inizio della routine vengono definiti i punti di Gauss e i pesi. Quindi l'integrale verrà fatto, allora vedete qui si inizializza la matrice di rigidezza con degli zeri 12x12, perché la matrice di rigidezza abbiamo detto che ha dimensioni 12x12, e poi qui facciamo un loop sui punti di Gauss, da 1 a 3, per fare proprio quell'operazione di integrale numerico, cioè la somma sui punti di Gauss. Sommiamo per ogni punto di Gauss quello che otteniamo. E poi all'interno, vedete, si comincia a prelevare la coordinata parametrica per il generico punto di Gauss quello che otteniamo. E poi all'interno si comincia a prelevare la coordinata parametrica per il generico punto di Gauss, si definisce la D, come abbiamo visto la settimana scorsa, la F e la J, l'inverso della F e così via. E così via la B, adesso ci siamo dimenticati come si costruiva la B ma in un certo momento l'abbiamo capito, siamo quindi soddisfatti. E poi Ke sarà dato da Ke, perché lo stiamo sommando a ogni punto di Gauss. In C sarebbe più uguale, ma non si può fare. Ke uguale Ke più B trasposto per A per B, per Iacobiano, per il punto di Gauss, per il peso di Gauss. È tutto qui. Da punto di vista del codice è una banalità assoluta. Poi capire bene tutto quello che avviene all'interno, come avete visto, non è una banalità. Però dopo alla sfida diventa estremamente facile. Proprio perché abbiamo deciso, ci siamo rassegnati, ma è così, a fare questo integrale numericamente. Che cosa abbiamo bisogno per effettuare questo integrale? Abbiamo bisogno di solamente due tipi di informazioni. La prima è la geometria, la matrice X che contiene le coordinate nodali e poi i parametri del materiale, il modulo di anche il più coefficiente di posto. Come ho detto prima, dove sono i coefficienti materiali? Sono qua dentro. E la geometria serve per fare tutto l'integrale. I valori nodali non c'entrano niente, sono fuori. Non ne abbiamo bisogno, per fortuna, se no questo non funzionerà. Ok, quindi questa è la matrice di rigidezza, la matrice di rigidezza elementare. Questo è per un elemento quadratico a sei nodi, voi potrete pensare che è semplice, è già un elemento bidimensionale di ordine 2, già abbastanza evoluto. Se mi metteste a pensare come potrete estendere un tetraedo, trovereste che poi le differenze non sono così drammatiche. Però, tecnicamente è un po' più complesso, lo farete guardando il codice commerciale, quando verrà Matteo a farvi tre esercitazioni su console, allora lì vi sbizzarrirete un po' a fare cose anche tridimensionali un pochino più complesse. Ok, qui, che invece dobbiamo guardare proprio dentro, lo facciamo solo in due dimensioni. Ma non credo che voi lo vediate come una limitazione, spero almeno. Ok, quindi questo è. Allora, noi abbiamo dunque dettagliato come effettivamente si riesce a costruire questa matrice che si chiama matrice di rigidezza elementare. Poi però, come esercizio, perché sennò ripeteremmo esattamente le stesse cose, se prima capite bene questo, poi capire questi due è immediato. Quindi magari farlo adesso confonde solo le idee. Ma una volta che avrete capito questo, proverete magari per conto vostro a vedere come le potenze delle forze esterne di volume e le potenze delle forze esterne di superficie possono essere espresse in una forma molto simile, dove c'è WI trasposto per una lista di contributi che si chiamano forze nodali equivalenti, che vengono dall'integrazione numerica, perché F è noto, le forze di volume sono sempre note, le forze assegnate sono sempre note, e quindi l'unica cosa che rimane è questo campo test che genera dunque questa WI trasposto. Ve lo lascio un esercizio, poi sulle dispense è tutto spiegato. Però è importante che facciate voi qualche piccolo esercizio perché sennò rimane tutto un po' buscato. Se avete difficoltà poi lo affrontiamo insieme. Quindi noi sappiamo che a livello di un elemento, e queste due rimangono da fare, riusciamo a effettuare questi integrali, la potenza degli sforzi interni, la potenza delle forze esterne, e ottenere queste espressioni che dipendono dai valori nodali del campo test e dai valori nodali del campo rispostamento. E qui ci sono poi i risulti. Ok? E questo conclude la prima parte. Adesso dobbiamo rispondere alle altre domande che avevo fatto all'inizio. Ho detto, il metodo alla galerkin l'abbiamo più o meno capito, il metodo agli elementi finiti l'abbiamo introdotto, però ci sembrano ancora molto lontani, perché quelle famose funzioni di forma globali non le abbiamo ancora introdotte, non ne abbiamo capito dove stanno. Come si costruisce la funzione Ud? Adesso dobbiamo rispondere a queste due cose ok? quindi apri la parte lì come sono fatte quelle che noi chiamavamo phi nel metodo Laguerrechian quelle che chiamavamo phi vi ricordate? le funzioni di forma e come è fatta la funzione e come è fatta la funzione quindi. Questa. Dobbiamo rispondere a questa cosa. Per farlo dobbiamo tradurre il concetto di funzione di forma globale. Attenzione che è semplicissimo. Dobbiamo solo fare un piccolo sforzo. Allora, innanzitutto una funzione di forma globale è riferita ad un nodo, ad esempio il nodo rosso, un nodo della mesh. Si può fare per tutti i nodi della nostra mesh. Allora, alcune definizioni. Chiameremo ωn il supporto locale di questo nodo. Che cos'è? È l'insieme di tutti gli elementi finiti che contengono il nodo. Per dirla più complicata dirò è l'insieme di tutti gli elementi finiti che contengono il nodo nella loro connettività. Questa espressione non vi dovrebbe stupire. Ad esempio, diciamolo in questo linguaggio, perché poi a volte è più facile esprimere in linguaggio informatico queste cose che in altri termini. Se n è il numero del nodo, io vado a vedere quali sono gli elementi e tali che esiste un certo k per cui t6 dell'elemento e, nodes k, dà proprio n. Cioè che il nodo n sta nella connettività dell'elemento vuol dire proprio questo che esiste un K esiste un K tale che N sia uguale a questa roba siete convinti di questo? banalmente si prendono gli elementi che contengono il nodo e li si mette assieme quindi omega non è la piramide, ma è la figura bidimensionale che è un po' a forma, in questo caso, di pentagono, che sta lì sotto. D'accordo? ωn quindi sarà il supporto della funzione di forma globale. La prima proprietà è che la funzione, la chiameremo n tilde, pedice n per indicare che è la funzione globale associata al nodo n. E mettiamo la tilde per chiarire che sono cose diverse dalle funzioni che abbiamo appena descritto, che erano definite solo su un elemento. Ok? Allora, innanzitutto n uguale a 0 al di fuori del supporto locale. Cioè, su tutto il resto del dominio è zero. E poi vediamo cosa c'è scritto qui. Su ogni elemento che appartiene ad ωn, questo ok, la funzione di forma globale è uguale alla funzione di forma locale nk, dove n e k sono legate da questa relazione. Cioè, cosa vuol dire? La funzione di forma globale è la collezione di tutte le funzioni locali sugli elementi che sono associate a quel nodo. Vi ricordate che la settimana scorsa vi ho detto che su di un elemento ogni funzione di forma è associata a un nodo specifico. Quindi prendiamo tutte le funzioni di forma locali che sono associate a quel nodo, le mettiamo assieme e viene fuori questa sorta di piramide. Questo disegno non vale nel caso del T6 perché le funzioni di forma sarebbero diverse, è valido nel caso degli elementi T3 dove le funzioni di forma sono dei piani, però dà l'idea, dà meglio l'idea, quindi l'ho utilizzata. Vi è chiaro? Quindi su ogni elemento, rileggiamo, su ogni elemento del supporto la funzione di forma globale n è la funzione di forma locale a patto che n e k stiano legate fra di loro da questa relazione, cioè che n sia nella connettività dell'elemento e che k corrisponda proprio ad n, sostanzialmente. Qualcuno potrà dire, va bene, ma io qui ho x e qui a. Queste due cose devono essere legate fra di loro attraverso la rappresentazione della geometria che abbiamo definito prima, cioè che x è uguale alla sommatoria, alla funioni di forma delle coordinate notate. Questo è chiaro, quindi ho costruito e lo posso fare in qualunque nodo. Se è un nodo di bordo, ci saranno pochi elementi su cui sommare questi due. Quindi non sarà una vera figura piramidale, sarà una parte. Però lo posso fare dovunque. Per ogni nodo posso crearmi questa funzione di forma n tilde, dopodiché chiaramente l'interpolazione, per come l'ho costruita, l'interpolazione dello spostamento può essere espressa anche in questa modo. Sommatoria che va su n, che va da 1 fino al numero di nodi di tutte le funzioni di forma globali moltiplicate per il valore nodale dello spostamento. Questa è la rappresentazione globale dello spostamento che coincide localmente con la rappresentazione locale di cui abbiamo parlato finora. Probabilmente le funzioni di forma sono le stesse, sono esattamente le stesse. Ok? Quindi questa è la rappresentazione globale del campo di spostamento. Ok? E la sommatoriaia su tutti i nodi quindi abbiamo fatto la transizione verso la rappresentazione globale però ci manca ancora di fare quella distinzione perché questo mischia ancora tutti i valori nodali che sono noti e quelli che invece sono iconici E invece se voglio rappresentare la funzione come la somma di due contributi separati, devo fare distinzione necessariamente tra quelli valori nodali che sono assegnati e quelli che sono incogniti. Ora, come si fa a fare questa distinzione? Dobbiamo fare un passo in più all'interno della base di dati, abbiamo bisogno... Vi ricordate che la settimana scorsa abbiamo guardato all'interno di qualche file input e vi ricordate che assegnavamo le condizioni al contorno anche in spostamento su alcuni lati. Quindi queste condizioni al contorno da qualche parte sono scritte. Quindi il pre-processore che noi non analizzeremo ma se volete vi prendete un po' di tempo vedete come funziona. Cosa fa? Entra all'interno dei file input che abbiamo assegnato a MATLAB, capisce in quali nodi sono assegnate delle condizioni al contorno e riempie questa struttura dati. La volta scorsa l'abbiamo... vediamo qua. E la quale cosa che ci interessa oggi è questa. Arricchiamo la conoscenza della struttura dati dei nodi. La volta scorsa abbiamo usato solo le coordinate, però ogni nodo ha anche altre cose. Blu lasciamolo stare, perché è predisposto per un problema accoppiato in cui ci sia spostamento in una variabile scalare come la temperatura, la potenza elettrica, ma adesso non ci interessa. Guardiamo solo questo. Allora, qui abbiamo U e Udof. U è il campo di spostamento, cioè le due componenti del campo di spostamento nodale sul nodo. UDOF è il grado di libertà assegnato, associato a ciascuna componente. Come li riempiamo? Il preprocessore ogni volta che trova un nodo in cui viene imposta una condizione contorno e spostamento in una particolare direzione, mette per convenzione meno 1 nella posizione corrisponente Udof. Ad esempio, cosa vuol dire qui? Che il preprocessore ha trovato che nel nodo N in direzione Q avevo imposto una condizione al contorno, che fosse 0, 2, meno 1000, era una condizione al contorno, e quindi mette per convenzione meno 1 lì. Per dire, attenzione, qui c'è uno spostamento noto. E poi, allo stesso tempo, anche se non c'è scritto qui, va a mettere nella lista U, va a mettere nella lista U in corrispondenza della stessa componente, il valore dello spostamento che impongo. Quindi, per processore, riempie U solo laddove c'è un valore nodale noto, altrove rimane indefinito. Quindi questo è quello che viene fatto per utilizzare le varie informazioni. Quindi prima di tutto il preprocessore riempie quindi tutti i posti opportuni di meno 1, poi dopo ricomincia a guardare tutti i nodi e ogni volta che trova uno 0, guarda su tutti i nodi e poi guarda il DOPS e trova uno 0, perché è stato inizializzato a 0, dice, beh, qui non ho condizione al contorno. E questo sarà una incognita. Questo componente di spostamento sarà un'incognita. E comincia a dare una numerazione globale, una numerazione globale a queste incognite. Quindi se il nodo N in direzione Q ha uno spostamento incognito, ci metterà un intero J positivo e questo J rappresenterà, questo numero intero positivo rappresenterà il numero globale dell'incognita. Sarà l'incognita e il numero 121. Ok? Quindi, ricordiamoci bene, facciamo questo sforzo. Se u doff è uguale a j maggiore di 0, allora la componente sul nodo n in direzione q è incognita. Se invece è meno 1, allora la componente è nota ed è data dalle condizioni al contorno. E dove vado a leggerla? Nel campo U. L'ho salvata nel campo U. Va bene? Adesso io sono pronto a fare questa decomposizione, che è molto simile a quella che c'è là sopra. Ud ha la stessa notazione, poi la vecchia decomposizione era espressa come degli scalari per le funzioni di forma. Qui l'ho chiamata semplicemente U0. Va bene, è la parte che dipende dalle incognite. Posso separarli. Ed è scritto in maniera che spero non vi ponga troppi problemi. Allora, innanzitutto parto da questa. Questa è l'interpolazione globale. C'è una sommatoria su n che va da 1 al numero di nodi globali. Io decido di introdurre una seconda, siccome ogni direzione si comporta a modo suo, faccio una seconda sommatoria anche sulle direzioni. Quindi invece di scrivere un, semplicemente un, scriverò unq eq. E quindi ho sommatoria anche su q, per poter distinguere le direzioni, per poter distinguere tra di loro le direzioni. Quindi, immaginate di aver introdotto la seconda sommatoria. Ud la definisco, quindi Ud che cos'era? Vi ricordate? Era quella funzione che rispetta le condizioni al contorno ed è estesa tutto il dominio. Sta la sommatoria su tutte le coppie n e q, dove n indica il nodo e q indica la direzione, tali che n e udof q sia minore di zero. Cioè vuol dire che sul nodo n in direzione q ho imposto la condizione al contorno. Perché questa quantità è, in virtù di quello che ho scritto qua sottpra, nota a causa delle condizioni al contorno che ho imposto. Questa funzione è la nostra definizione di UDI, perché rispetto a tutte le condizioni al contorno, è estesa tutto il dominio, ovviamente sarà zero per la maggior parte, perché queste funzioni n sono, come abbiamo detto prima, zero quasi ovunque tranne che sul supporto omega n. Quindi va a zero molto presto, ma è definita su tutto il dominio. Certamente devo dire che questo spazio è inteso nel senso degli elementi finiti, perché ormai ho discretizzato tutto, la geometria, l'interpolazione, non è più uno spazio continuo, è uno spazio a dimensione finita degli elementi finiti. Gli è chiaro questo? Sono stato obbligato a distinguere quali sono i nodi, sono su tutti i nodi, sono su tutte le direzioni ma prendo solo quelle componenti in cui ho una condizione contorno imposta. Poi invece la parte incognita è tutto il resto. Tutto il resto. Somma o strutture copie tali che abbiano una quantità maggiore di zero. Un numero, qualunque esso sia, ma maggiore di zero. Perché lì allora c'è un'incognita per la convenzione che ho assunto. Questa è una quantità nota a causa delle condizioni a contorno. Questi sono dei parametri incogniti, sono le nostre incognite. Di torna? Se no fate domande, per carità. Per W, se vi ricordate, W alla galerchia veniva interpolata esattamente nella stessa maniera, ma non aveva Ud, perché W sa nulla sulle parti dove ci sono condizioni di rischietto. Quindi rimane solamente l'equivalente di questa parte. Preferisco usare degli indici diversi, vedete qui la sommatoria è fatta su NQ, qui invece cambio gli indici della sommatoria perché poi dopo mi servirà, come spesso accade, avere degli indici separati, se no faccio confusione. Quindi sommo su tutti i nodi, tutte le direzioni, laddove c'è un'incognita, allora il campo è espresso così. Perché? Che succede? Vediamo se ve lo ricordate. Non c'è scritto qui. Che succede quando invece ho questa quantità negativa? Su di un nodo ho questo numero negativo, cioè un meno 1. Quando trovo un meno 1 qua, vuol dire che lì ho una condizione a contorno imposta. E allora che cosa so del valore nodale di W? Siccome c'è 0, so che è 0. Quindi non lo metto proprio perché so che è 0. Cioè l'equivalente di questo è 0. Manca perché è 0. Per il resto è identica. Per il resto è identica. Quindi ho fatto la fatica ad introdurre quella struttura dati, ma vedete che con quella struttura dati riesco quindi a distinguere in maniera molto efficace le parti che sono note e le parti che sono incognite. E per il momento ho ricopiato solo nel riguardo rosso le due cose che ho detto prima. Il riguardo rosso è quello di prima. E poi anche questo è la stessa cosa, però ci serve per fare un passo ulteriore, un piccolo passo ulteriore. Andiamo lentamente perché sono cose, alla fine vedete che sono cose semplici, però tecnicamente un filo complesse richiedono un po' di riflessione. Allora, questa è la stessa cosa di prima. Se nel nodo n direzione Q trovo una quantità positiva, allora la componente nodale è incognita. E qui c'è scritta solo una cosa in più, che crea una lista di incognite. Crea una lista di incognite che chiamo lista 1 con questa doppia barra verticale, perché è una lista globale. Sarà una lista che contiene tutte le incognite del mio problema. Vedete che qui la componente j esima, perché j? Perché c'è scritto j qua. Perché ho salvato, ho detto che l'incognita lì è la numero j, quindi metto in questa lista globale, in posizione j, questo valore incognito. Quindi mi creo la lista completa delle incognite. Le incognite del mio metodo e degli elementi finiti saranno i coefficienti di questo vettore, di questa lista, che nel metro alla galetta chiamavo alfa, qui invece chiamerò u. Alfa j la qui uj, perché hanno un significato di spostamento. Quindi dovete immaginare questa lista globale di incognite e la posizione jesima contiene l'incognita numero j definita da questa struttura dati che ho introdotto. Quindi l'interpolazione dello spostamento che è data dalla somma di queste due cose qui si esprime come Ud, che è la prima riga, più la sommatoria di queste Uj, che sono queste, Uj sono questi coefficienti messi all'interno della lista, che moltiplica questa funzione vettoriale Φ, e questa Φ non è altro che il prodotto di nn per eq, nn per u, ho solo cambiato il nome, per metterla nella forma del metodo alla Galerkin. Questa è esattamente la decomposizione dello spostamento alla Galerkin, con l'unica differenza che invece di chiamare questi AFA li ho chiamati i J. Questa è dunque la risposta a una delle domande, come si crea l'interpolazione alla Galerkin. Per W vale esattamente la stessa cosa, solo che invece di chiamare la lista globale U la chiamerò W e la posizione iesima sarà il parametro arbitrario associato a questo nodo in questa direzione, se invece è meno 1 so che il valore nodale è 0, perché W si deve annullare, perché è nello spazio C0. E l'interpolazione si esprime utilizzando esattamente le stesse funzioni di forma moltiplicate per dei parametri diversi che alla galerina incavamo beta e qui invece chiamiamo w. Ok?
 Sono le cose che dicevo prima, cioè ha messo meno 1 sui nodi in direzione in cui ci sono delle condizioni a contorno imposte e ha messo in U il valore imposto. Tutto il resto è 0 in questo momento. Tutto il resto è 0. Poi vedi proprio questo. Comincia con la numerazione dell'incognito nodale. Questa è una scelta, ce ne sono mille altre, ce ne sono mille altre. Cosa fa? La spiegazione magari dopo ve la darò. Però qui procede per elementi, qui procede per elementi, per ogni elemento guarda tutti i nodi, prende il nodo nella connettività, per ogni direzione, se trova che in quella direzione Udof è uguale a 0, vuol dire che lì non ho una condizione a contorno imposta, allora incrementa il numero di equazioni, e questa è la numerazione, e salva all'interno di Udof il numero dell'equazione. Perché l'ho fatto per elementi e avrei potuto benissimo farlo per nodi, cioè invece di fare il loop sui nodi, partire su tutti i nodi, scusate, invece di fare il loop sugli elementi, farlo su tutti i nodi. Il motivo è molto serio perché volevo sviluppare un codice in cui alcuni elementi non fossero associati a materiali, poterli attivare in un secondo momento e quindi volevo associare i codici solo agli elementi che avevano effettivamente associato un materiale. Poi non l'ho sviluppato, potreste benissimo fare come esercizio cambiare questo e fare un loop solo sui nodi for n che va da 1 fino a analysis.mn perché quello è il numero dei nodi fare la stessa cosa senza andare a prendere la connettività cioè è una cosa molto più snella tanto la numerazione la buona notizia è che qualunque sia la numerazione che tu fai che sarà certamente una porcheria esattamente come la mia MATLAB prima di mettersi a risolvere il sistema, riordina, come vi ho fatto vedere la prima lezione, che prima la matrice viene tutta piena, MATLAB riordina e viene tutto concentrato sulla diagonale, che dà infinitamente miglior condizionamento. Quindi non vi dovete preoccupare di questo, l'ordinamento dell'incognito è fondamentale per mantenere la banda della matrice molto stretta, ma ci pensa per nostra fortuna MATLAB. Quindi si fa quello che vi ispira. Però una varrà. Quindi questa è proprio la prima cosa. Come faccio a stabilire l'ordinamento delle incognite? In questa maniera molto banale. Poi la seconda cosa, di cui parleremo magari solo alla fine perché non è molto importante, è che, in sigo meglio, devo risolvere sistemi anche abbastanza grandi. Non posso allocare delle matrici n per n. Mettete di avere anche solo 10.000 incognite, che sono pochissime. 10 alla quarta, una matrice quadrata sarà di 10 alla 8. E io voglio dire a Matelo, guarda che la matrice sarà sparsa, salva solo i coefficienti diversi da zero, perché sennò pazzisci subito, vai fuori di memoria. Per quanto memoria tu abbia, prima o poi riesco a farti saltare. Allora si usano le allocazioni sparse, spalloc, sparse alloc, in cui sostanzialmente si crea tre liste, la lista della riga, il sera colonna e il coefficiente. Però il prezzo che bisogna pagare è dargli una stima per eccesso dei coefficienti che ci saranno nella matrice. E allora non è molto difficile tutto contenuto qui, se abbiamo tempo, dopo vi spiego come funziona questa banalissima stima per eccesso dei coefficienti che ci sono, del numero di coefficienti che ci saranno nella matrice. Quindi, uno, numero alle equazioni, due, fa questa stima, se non riesco andate però a leggere nella dispensa perché è curioso, è una cosa proprio di topologia banalissima, approssimativa. E poi dopo vedete che siamo già arrivati alla riga 67 e comincia con quello che vedremo adesso, il vero nucleo, che sono queste 20 righe, che è l'assemblaggio della matrice, che sarà abbastanza difficile da capire, abbastanza pesante da capire, ma che si traduce in 20 righe, di cui la maggior parte sono cose banali, perché comincia a avere, questo è ne, il numero di nodi di un elemento, quindi questo è ne 16, prende il materiale, inizializza a zero alcune cose, e poi fa un loop sugli elementi, prende il nodo, crea la matrice, crea alcune cose, poi crea la matrice di rigidezza, questa è la funzione che abbiamo visto prima, per ogni elemento, per ogni matrice, per tutti i parametri, crea la matrice, e poi l'assemblaggio sono queste cinque rive. Anzi, l'assemblaggio della matrice sono una, due, tre. Quindi tutto quello che faremo adesso, che ci sembra complicatissimo, poi alla fine diventa queste tre righe qua, l'assemblaggio. Alla fine di questo lui avrà la matrice K, avrà il vettore F del termine noto e fa la soluzione del sistema. Se la fa lui. Ah no, scusate, scusate, questo è l'assemblaggio anche delle forze di superficie applicate. E poi dopouzione. Questo è WK backlash F, cioè lui si scende il solutore. Questi sono i comandi che abbiamo visto l'altra volta per rinumerare, commentati, per vedere come effettivamente riesce a renderla concentrata sulla diagonale. E poi tutto ilastera un post-processing, cioè riempie, forse è la pena di vedere solo questa cosa qui, avendo risolto per il vettore U delle incognite, fa un loop sui nodi, questo è pertinente alla tua domanda, quindi ritorniamoì. Lui all'inizio, vi ricordate, all'inizio aveva riempito solamente i valori dati. Il preprocessore aveva riempito il campo U solamente laddove abbiamo un valore di spostamento imposto. Adesso lui si è trovato tutti i valori nodali incogniti, risolvendo il sistema, e deve andare a riempire il campo dei nodi con gli spostamenti che ha trovato. Quindi fa un loop sui nodi per le due dimensioni. Se prende il DOF, che è il valore per il nodo N direzione D, prende il DOF, se il DOF è positivo, vuol dire che è un'incognita, allora va a prenderlo all'interno della lista delle incognite. E fine. Alla fine di questo loop avrà riempito tutti i nodi con i loro spostamenti e sarà pronto a fare post-prestest, a plottare lo spostamento, a calcolarsi e a plottare gli sforzi, ma questa è una cosa che, quello che viene dopo è di secondaria importanza. Cioè, certamente prende un po' di tempo da sviluppare, ma la parte principale è la prima, in particolare l'assemblaggio. Ok, ditemi voi, volete fare una piccola pausa prima di affrontare l'assemblaggio? Scegliete voi. Ok, una decina di minuti poi ricominciamo.
 Il nostro istinto dei parti, sappiamo quindi che abbiamo un approccio alla Gretchen, se con la nostra discreditazione ripetessimo quello che abbiamo visto all'inizio della settimana scorsa, arriveremo a formulare un problema fatto così, in cui abbiamo Udoppio trasposto, KU, dove K è la matrice di rigidezza globale, W contiene tutti i parametri del campo test, U è incognite, FU da dove viene? FU viene dalle parti di spostamento assegnate, esattamente come accadeva in metodo Agavelkin, FX viene dalla potenza di questi termini esterni e la somma di questi due la chiamiamo f e quindi abbiamo w trasposto f. Questo deve essere imposto qualunque scelta di w e abbiamo fatto vedere che questo è prima di risolvere il sistema k1 uguale a f. Quindi, siccome l'abbiamo dimostrato per un generico metodo alla galerkin, deve valere tal quale anche per gli elementi finiti. Quindi noi sappiamo a priori che questo è il risultato finale. Dobbiamo capire come costruire le matrici di rigidezza globale e come costruire il vettore F. Questo è quello che ci manca. Questa cosa, avendo a disposizione le routine elementari che calcano, cioè le matrici a livello elementare, si chiama procedura di assemblaggio. Anche qui lo facciamo solo per questi due termini. Perché per questi due termini? Perché la somma di questi due termini è l'integrale del campo di spostamento completo, la parte incognita più la parte assegnata, che poi genera una parte che va a finire a termine noto, questa qui. Però valutiamola tutta assieme, cerchiamo di capire come si assembla una k ed fu, poi come esercizio vi lascio da capire come si assembla invece f est. Se sarò capaci di fare queste cose, ovviamente alla fine abbiamo tutto il sistema. Quindi adesso noi ci limitiamo a discretizzare questo, dove questo è il campo di spostamento globale, anche se qui l'ho espresso diviso in due, e chiaramente il principio delle potenze virtualii è additivo per cui lo posso valutare come somma degli integrali su ogni elemento invece di esprimere come integrali sul dominio lo esprimo come somma degli integrali su ogni elemento e quindi questo e quindi so che su ogni elemento vale quello che abbiamo detto prima avremo una sommatoria sui elementi di WI trasposto, KIUE. Questo è sempre vero. Però questa dunque sommatoria deve generare, deve corrispondere a questa. I problemi sono vari. Qui per ogni elemento in UE, vi ricordate? Vi ricordate cosa avevamo in UE? Avevamo per ogni elemento l'elenco di tutti i valori nodali, primo nodo, secondo nodo, 12 cose che non distinguevano assolutamente tra valori dati e valori incogniti. Qui invece abbiamo solo i valori incogniti. I valori dati servono per generare questa FU, cioè è molto diverso, ma qui abbiamo lo sommatore sugli elementi, qui invece ho un sistema. Quindi come facciamo? A partire dalla conoscenza delle KE, perché questo è il punto di partenza, ipotizziamo di essere capaci di calcolare per ogni elemento la KE, ipotizziamo di conoscere la struttura dati che abbiamo costruito, come facciamo a utilizzare queste matrici per riempire OK o FU questo è l'assemblaggio detta così sembra una stupidata da capire come si fa anche poi alla fine abbiamo visto che sono tre righe quindi anche alla fine è una stupidata per capire invece il processo bisogna rassegnarsi e introdurre un paio di cose. Dobbiamo fare un po' di pulizia levamente e rivedere alcune cose. Innanzitutto riscrivo questa relazione utilizzando gli indici. Questa sarà la sommatoria su IJ, abbiamo visto WI, KIJ, UJ. Invece di avere un trasposto KIJ. E qui avremo invece la sommatoria su tutti gli elementi, della sommatoria su T, W, E, P, K, E, P, Q, U, E, Q. Quindi questo non ce lo vieta nessuno. Possiamo esprimere questi prodotti in lista matrice vettore come sommatoria. Come sommatoria. P, primo passaggio. Secondo, e noi li ritroviamo qui quindi questo lo ritroviamo qui per ogni elemento immaginiamo di considerare un elemento perché se capiamo come lo facciamo per un elemento poi il codice lo ripeterà per tutti gli elementi questa è la slide è una sola slide e poi dopo c'è scritto come fa il codice matter, quindi dobbiamo semplicemente capire questa. E dobbiamo introduire, introduciamo per ogni elemento due nuove liste, GE e UD. Allora, UD è facilissimo. UD, innanzitutto sono tutte liste di 12, lasciate stare il fatto che Ud è la dimensione, quindi 2. Alla fine abbiamo Uge, per il triangolo a sei nodi sarà 12 e anche Ud sarà 12. Quindi è simile alla stessa dimensione degli spostamenti nodali Ue e W. Solo che con Ud, Ud lo riempiamo solamente... è definito qua... dov'è che lo... ah, non l'ho scritto... va bene... Ud viene riempito all'inizio, prima di aver risolto il sistema, noi non conosciamo i valori nodali, conosciamo solo quelli che sono assegnati. Gli altri sono a zero, per cui se lo riempiamo così, riempiamo Ud con tutti i zero, tranne laddove sono imposti degli spostamenti assegnati, e quindi Ud sarà una lista per la maggior parte di zeri, conuni numeri diversi da zero laddove lo spostamento è imposto. Però è 12, con lo stesso identico ordinamento di UE, quindi le due componenti del primo nodo, le due componenti del secondo e così via. Quindi Ud contiene i valori assegnati di spostamenti annodali laddove il preprocessore li ha trovati. GE invece che cosa contiene? GE viene riempito con due componenti primo nodo, due componenti secondo, esattamente con lo stesso criterio, però con il valore dei DOF. Quindi contiene, trasforma risultanzialmente in una lista di 12 i gradi di libertà che appaiono sui nodi di un elemento. Quindi, secondo voi, proviamo a cercare di capire quello che c'è scritto qua. Perché se capiamo queste condizioni, allora l'assemblaggio sarà chiaro. Magari vi può sembrare... Però seguiamolo passo passo. Ue, posizione Q. Q. Che cos'è UE? UE è la lista nodale degli spostamenti. Primo nodo, secondo nodo. La posizione Q, che cosa conterrà? Che cosa conterrà? Abbiamo due opzioni. Contiene o un'incognita o uno spostamento dato. Come facciamo a decidere se è un'incognita con la base dati che ci siamo costruiti? Come facciamo a decidere se è un'incognita o uno spostamento dato? Beh, allora, entriamo in GE, posizione Q, e l'abbiamo riempito con i DOF. Se troviamo un numero maggiore di 0, vuol dire che lì abbiamo un'incognita, e sarà l'incognita globale il numero J. Se questo GE è uguale a j. Chiaro? Questo vi è chiaro? Cioè se in je troviamo un numero maggiore di 0, vuol dire che questa cosa qui è un'incognita e la numerazione globale e il numero globale dell'incognita è j. Esattamente il numero che è stato salvato qua dentro. Se invece trovo in je un numero minore di 0, allora vuol dire che DOF è uguale a meno uno, e allora questo è assegnato, è un numero che è noto. Quindi utilizzando questo G, G mi serve semplicemente, perché io scorro la lista di 12, capisco subito se quel particolare coefficiente è un incognita oppure è un dato. Se è un incognita mi dice anche qual è il numero globale dell'incognita. Se è un dato, dove vado a prendere il valore? In Ud. In quella posizione Q dove ho trovato 0, entro in Ud e ho il valore dello spostamento assegnato. Sono quindi due liste che servono proprio a questa cosa qua. Chiaro? Per lo doppia funziona esattamente alla stessa maniera, solo che la differenza è che ogni volta che troviamo g in posizione p minore di zero, allora questo valore è zero, perché lì lo sappiamo che lo doppia sta nello spazio c0, quindi si deve annullare dove abbiamo degli spostamenti imposti lo spostamento se volete è esattamente uguale a qua solo che lo spostamento imposto è 0 ok? allora quindi abbiamo introdotto questa tutta una data e abbiamo capito un po' come funziona e adesso dobbiamo fare questo riquadro rosossi, lo stesso che c'era nella slide precedente, nella slide precedente, come, allora, ritorno alla cosa che devo fare, conosco KE, e come faccio a decidere dove vanno a finire i coefficienti di KE? Vanno a finire in K globale o in FU? Allora, c'è un'osservazione, prima di tutto un'osservazione. Farò un loop su tutti i coefficienti di ke, quindi avrò un doppio loop su 12 e 12, con tutte le righe e tutte le colonne, quindi farò un loop esattamente su p e q, che vanno da 1 fino a 12. Quindi considero un particolare coefficiente Ke PQ, quindi sto considerando quello. Questo è premoltiplicato per W e P e postmoltiplicato per U e Q. Mi chiedo, W e P è 0 o è un coefficiente arbitrario? Dove lo capisco? Eh, qua. Se Ge e P è maggiore di 0, allora è un coefficiente arbitrario. Dove lo capisco? Eh, qua. Se GEP è maggiore di zero, allora è un coefficiente arbitrario e dovrà essere messo nella riga iesima. Se invece è zero, è inutile considerarlo perché non darà nessun contributo. Quindi vedete che io faccio qualcosa solamente se questo GEP è maggiore di zero, perché se non è maggiore di 0, il coefficiente è nullo, quindi non lo devo considerare. Allora, ripeto, se ne sto considerando la posizione P, se G e P è maggiore di 0, allora questo corrisponderà all'incognita, al coefficiente arbitrale numero I, quindi a w e andrà a riempire un coefficiente della riga di k. Se invece trovo un numero minore di zero, neanche lo considero perché tanto so che il coefficiente verrà posto a zero. Non è arbitrario, ma è zero. Prima osservazione. E poi invece ueq, per ueq vale un po' la stessa considerazione. Se trovo che GEQ è maggiore di zero, allora questa è un'incognita e il numero che è salvato all'interno di GQ, J, mi dice qual è il numero globale dell'incognita e mi dice quindi che questo coefficiente KEPQ dovrà andare a contribuire al coefficiente KIJ dove I è questo numero, IJ è quest'altro. Perché WI e UJ corrispondono a queste due quantità se valgono queste due relazioni. Se invece trovo che GQ è minore di, vuol dire che questa quantità è assegnata. E che quindi il prodotto KePq per questa quantità andrà a fornire un contributo a termine noto. Cioè KePq per questo valore di spostamento assegnato genererà un contributo al termine noto. Se lo so fare per una generica coppia di PQ, lo posso fare per tutte le coppie possibili di PQ e per tutti gli elementi. Come si traduce in linguaggio MATLAB questo? Devo fare. È veramente necessario fare il loop su tutti i PQ? Beh, innanzitutto ci sarà la prima fase che genera GE e UD, che sono le due liste. GE è 0, vedete, DNE è 12, D che è uguale a 2 per NE che è 6, quindi è 12, UDE è questo secondo, un'altra lista di 12, poi va a vedere tutti i nodi dell'elemento, prende il nodo globale, riempie GE con i DOF, con i gradi di dualtà, riempie UDE con gli spostamenti. Ricordatevi che a questo livello gli spostamenti sono tutti 0 tranne quelli imposti. Quindi si crea prima di tutto queste due liste. E poi fa l'assemblaggio di questo. Qui sono riassunte le due condizioni. Se questa Gp e Gq sono maggiori di 0 e pari ad i e a j, allora questo coefficiente deve andare a essere sommato al coefficiente ij di k. Al altrimenti va a dare un contributo ad FU. Invece però di farlo per tutte le coppie possibili di E, P e Q, Matta lavora molto bene per SAB array, quindi trova tutti, si salva in LA tutti gli interi di GE che sono maggiori di zero, scusate, tutte le posizioni di GE che sono maggiori di zero, e fa l'assemblaggio ad un botto. Quindi prende la sottomatrice di KE che corrisponde a LE0, cioè a quelli che sono maggiori di 0, la somma direttamente a K. È come fare un loop su tutte le posizioni, solo che lo fa in un colpo solo. Perché matta è molto... mutazione di matta compatta che sostituisce i cerchi, sostanzialmente. Trova invece le posizioni di G che sono minore di zero, queste, G minore di zero, allora va a prendere lo spostamento in corrispondenza di queste posizioni, lo spostamento imposto, lo moltiplica per la matrice KE e va a sommarlo al termine noto. Potreste benissimo fare, invece di utilizzare questa notazione compatta di Matlab, fare un loop su P e Q, loop P da 1 a 12, loop for P da 1 a 12, for Q da 1 a 12, se G e Q è maggiore di... Allora, dite, I uguali a G e P, se è maggiore di 0, fa questo, e poi vi ho a vedere quanto vale G e Q è maggiore di 0, fai questo, e poi vi ho a vedere quanto vale G e Q, se è maggiore di 0 fai questo, se non fai quell'altro. Matta, per favore. Questo è l'assemblaggio. Questo è l'assemblaggio della matrice che rimarrà talquale per tutte le matrici che troveremo. Settimana prossima vedremo la matrice di massa per fare la dinamica poi faremo problemi di termica quindi avremo la matrice di conducibilità stessa identica cosa la matrice di diffusività stessa identica cosa cioè tutte le matrici verranno assemblate con questo stesso criterio quindi vale la pena secondo me passare 10 minuti, quarto d'ora di vedere queste cose, capirle una volta, perché poi direte, ah beh sì, l'assemblaggio, l'ho capito una volta, so come fa, quell'aspetto lì, verrà fatto sempre la stessa maniera. Un buon esercizio per mettere a prova la nostra comprensione è vedere l'assemblaggio dei termini di forza esterna. Se capite questo, poi vedete se capite, per la la seconda parte più piccolina dell'assemblaggio delle forze esterne e questo sostanzialmente è un po' la conclusione del motore principale del codice elementi infiniti quindi integrali elementari elementi soparametici integrali elementari assemblaggio delle matrici globali, risoluzione del sistema, post-processing. Adesso, prima di magari guardare qualche, a seconda del tempo che ci rimarrà, guardare qualche altro piccolo dettaglio del codice, io vi propongo un esercizio per avvicinarci alla anzi ve ne lascio due in realtà vi faccio subito vedere quali sono quali sono il 1 è appunti apro la situazione degli appunti fino adesso
 che dovete applicare alla barra superiore per riuscire ad imporre lo spostamento verso il basso. Vi guida, trovate la soluzione, però è una cosa che dovete capire voi. Magari provate a farlo, a vedere se riuscite a scrivere voi queste righe, l'esercizio e la scrittura di questa decina di righe. Leggete all'inizio, vi spiega che cosa dovete usare, che cosa dovete fare, provate a fare questo esercizio. Adesso invece facciamo l'esercizio che è qui, 3.10.13. Usiamo questo codice per verificare la rigidezza di una molla MEMS, per vedere se troviamo i risultati analitici. Quindi dovete fare un file input, ma il file input sarà banalissimo e vi spiego che cosa vogliamo fare. I più bravi riusciranno a fare delle molle folded, invece all'inizio solo una molla singola non forte. Allora gli slides, code eccolo qua. Allora vi faccio vedere alcune immagini che per voi immaginano dei cipi, penso che siano stranote, non sto a raccontarvi come vengono prodotti, memes, etching, non etching, polisilicio, questo è il corso coligiano piano ve l'ho già fatta vedere in maniere e qui ci sono delle immagini di vecchi MEMS questo era un vecchissimo accelerometro 2D adesso non si fanno più così preferiscono farli separate le componenti XY e Z sono tre device indipendenti questa invece era una cosa che mischiava X e Y in una stessa massa e ci ci sono tante molle, le molle non sono altro che elementi solidi, flessibili. Quindi questo è l'ancoraggio, vedete qui in mezzo c'è l'ancoraggio, questo vuol dire che è attaccato al substrato, poi ci sono queste aste sottili, che sono qui riprodotte, che fanno un doppio cerchio, che fanno un doppio loop chiuso, e poi vanno a toccarsi a quello che si chiama lo shuttle, la massa forellata che si deve rimuovere. E così tutti i MEMS sono sospesi al suo strato tramite elementi flessibili di questo genere. Non ci sono cerniere, snodi, è tutto monolitico, è tutto monolitico, solo che si sfrutta la deformabilità delle parti per lasciare muovere il MEMS. Questo è uno zoom, ci sono vecchie immagini SEM, adesso le fanno meglio, qui vediamo, questo è un plate che serve a separare dal resto, la vera trave è questa qua, e vedete che qui ce ne sono due che fanno parte del loop chiuso di prima. Allora ci sono delle formulette che servono a dimensionare queste, questo è un altro esempio, queste sono delle folder beams, caso più tipico, ancora qui, questo è il suo strato, qui la molla si richiude su se stessa con un serpentello per aumentare la cerovolenza sostanzialmente e poi si attacca allo shuttle, questo frellato che si deve muovere. Cosa serve ripiegarla così? Serve appunto, come ho detto, a renderla meno rigida mantenendo compatto lo spazio. E troverete di tutto. Poi ci sono le molle 3D, le molle torsionali che è l'accelerometro torsionale, che sono invece diverse, che fanno uso delle formule della torsione. Però ritorniamo al nostro caso. Per dimensionare queste molle, tutti i designer mens utilizzano queste formulette banali. Allora io vi propongo di fare prima questo esempio e se per voi è troppo rapido provate a fare magari non tre perché vi dovete mettere lì a creare la geometria ma fate un avanti e indietro e a verificare questa formula. Questa però è semplicissima. Vi propongo di discretizzare una travetta snella, quindi sceglierete voi lo spessore e la lunghezza, che è incastrata qua, e qua sotto ha un pattino, cioè vuol dire che lo spostamento è permesso in questa direzione, applicate una forza di superficie, una forza di superficie, e questo genererà uno spostamento di questo genere. E andate a verificare se vale questa formula, che lo spostamento d che otterrete sarà un dodicesimo di p, che è la forza. Beh, voi non potete applicare una forza concentrata nel codice, ma è una forza distribuita. Però sapete quanto è lungo, voi applicate una forza distribuita costante sul vostro segmento e quindi avete la risultante, no? L è la lunghezza della trave, E è il modulo di Young che utilizzerete e J è il modulo di inerzia, è il modulo di inerzia a pressione della trave che nel vostro caso partic trave che nel nostro caso particolare sarà un dodicesimo di t al cubo dove t è lo spessore della trave noi vogliamo vedere se questa formula è accurata oppure no e quindi come primissimo esempio io vi dico fate una geometria di questo genere, una traretta di questo genere, incastratela, qui mettete dei carellini, come era, e però applicate una forza distribuita F uguale P diviso T, come P è questo, ok? E vedete se effettivamente il codice vi predice questo spostamento. Ora, attenzione, stiamo lavorando in 2D, mentre queste formule valgono bene in 3D. Allora, vi dico, senza troppo giustificarlo, che per avere una buona corrispondenza con queste forme bisogna usare l'instrain con un modulo di passione uguale a zero. Perché zero? Perché se il modulo di passone è zero la struttura non si contrae in direzione ortogonale allo sforzo e quindi che sia un problema 3D oppure 2D non cambia niente. Provate a vedere con nu uguale a zero cosa viene, provate poi a mettere un nu diverso da 0 e vedete se continua a coincidere e con che livello di approssimazione. Ok, quindi, passaggio, creare il geo, chiamatelo spring, spring.geo, che contiene questa geometria, ma lì su 4.0, sc 4.0. Provate a farlo, mettetevi assieme, non è inutile farlo.
 In questo passaggio invece di farlo così dovete fare un piccolo cerchio in cui la transizione si adorce. Ma questo lo rispondo con la verità, perché se andate a vedere le molle, si magari un po' assomigliano veramente a delle cose, adesso qui sono figure brutte, sono foto brutte, però più zoomiamo e più si intravedono dei filettini, cioè ci sono delle curve, non è mai ad andare a vedere. Ricordatevi, migliorare i soldi spingoli vuol dire sforzo infinito e vuol dire che il materiale si rompe. Ora, se volete un'indicazione sugli spostamenti va benissimo, se volete invece andare a misurare il stato di sforzo in maniera corretta, volete essere sicuri che la vostra molla non si rompa, cosa che è routine, è un'analisi routine, dovete garantire una mesh migliore, quindi potete fare anche voi gli esercizi, evitare il fold con i fillet, definendo un fillet piccolino e trovare un compromesso. Chiaramente se fatto un raggiungolatore piccolo gli elementi lì dovranno essere piccoli. Ok, allora, quindi questo è semplicemente per dire come si può stimare la rigidezza di una molla usando questo strumento. La cosa che volevate fare voi, cioè imporre lo spostamento diverso da zero, richiede però dopo di essere capaci di calcolare la reazione vincolare a posteriori, perché il codice non vi dice qual è, vi dice solo quella distribuzione degli sforzi. Come fate fate voi a calcolare la reazione vincolare l'esercizio che vi ho suggerito è proprio su questo come calcolare accortamente una reazione vincolare utilizzando sempre il principio delle potenze virtuali in una forma leggermente diversa lì vi spiega prov quale... provate, provate a farlo. La soluzione è lì dentro, cercare di farlo voi, poi si indiciate la soluzione. Ok, allora, quindi, analisi vedete che qui è già programmato per Direction Force, per Instagram, adesso non so se c'è lì. Secondo me non ve lo metto. È stato cattivo, ve lo dovete copiare e dare il mio penso. Allora, alcune considerazioni finali. Poi anche sto arrivando ai miei limiti, come ho detto oggi non sono in grandissima forma, però alcune considerazioni le dobbiamo fare. Allora, uno, la procedura di assemblaggio è una cosa tecnica, però veramente vista, una volta capita una volta, l'avete capita per tutte, e ne vedremo almeno una decina, per cui capitela una volta e poi siete fiduciosi che tutto il resto sarà fatto. Poi, alcune cose, uno è la bandwidth, cioè la dimensione della banda e della matrice. Adesso magari lo apprezzate di più, lo si può vedere proprio anche in questo esercizio. Scommentiamo queste linee, spy k, p e spy. E vi ricordo che è molto utile fare il debugger quindi vi mettete un pallino rosso qui di fianco alla linea dove volete che lui si fermi lo lanciate prendete il vostro file quella che è la spring folder ad esempio che stavo facendo lui assembra vedete che anche va piuttosto... ci arriva fino a lui. E cosa fa? Vi fa vedere la rappresentazione grafica della vostra matrice. Ora, tutto sembra meno che sparsa. No. Sono circa... fate un conto, sono circa 16.000, 17.000 incognite, no? Più o meno. 16-17.000 incognite, quindi si fa abbastanza presto. 2 per 10 alla quarta diventa 4 per 10 alla 8 coefficienti. Eppure lui vi dice che di NZ, che sono il numero di coefficienti di regalità al zero, sono solo 362.000, che quindi sono circa 4 ordini di grandezza meno. Però è ben nascosta, no? Allora si chiede a MATLA, e ci sono degli argomenti raffinatissimi, di fare una rinumerazione delle incognite. Invece di farla alla cavolo, come l'abbiamo fatta prima, gli si dice rinumera l'incognito in modo da minimizzare la larghezza di bando della matrice. E ci sono tanti algoritmi, questo simrcm è un algoritmo, se volete scrivete help, vi dice un po' come funziona, in letteratura trovate, quindi io lo faccio, lui ha rinumerato, quindi p è una permutazione delle vecchie incognite, e adesso faccio spy di k permutato, faccio spy di k permutato e allora vedete che effettivamente la matrice è sparsa, qui si vede meglio effettivamente. Nessun problema, anche se non gli avessi chiesto, ma prima di risolvere il sistema si rifà la numerazione dei ricordi. Ok, perché? Perché è importante fare questo? Ma per il motivo seguente, che quando voi risolvete numericamente un sistema, ovviamente non calcolate mai l'inversa, come forse vi hanno insegnato, ma si usano le decomposizioni della matrice. Ad esempio se la matrice, come in questo caso, è definita positiva, perché è definita positiva? Perché nel nostro caso abbiamo bloccato tutti i moti rigidi, non sono possibili i moti rigidi, quindi sappiamo che K è definita, qualunque spostamento assegniamo genererà un'energia positiva. Il senso è questo. È definita positiva. Simmetrica è definita positiva. Per cui si sa che è possibile trovare questa decomposizione che si chiama decomposizione di Cioveschi per cui c'è un algoritmo molto semplice che trovate in tutti i libri di analisi numerica. Cioè viene rappresentata come il prodotto di una matrice triangolare, L, per una matrice diagonale dove la matrice diagonaleale contiene tutti i coefficienti positivi, per la stessa matrice triangolare trasposta. Ora, risolvere un sistema di matrice triangolare è facilissimo, perché si comincia dalla prima e poi si va avanti, e quindi una volta che si ha questa decomposizione, cioè è facilissimo risolvere il Se Matt Labb ha le sue tecniche per capire se la matrice è definita positiva, se lo è, applica la decomposizione di Cioveschi. Se ora fate la decomposizione di Cioveschi, L avrà lo stesso skyline, lo skyline è praticamente questa linea che contiene tutti quanti i coefficienti diversi da zero, è questo grigino, se c'è un coefficiente lontano allora ci deve essere un grattacielo che lo va a prendere, così ricostruite lo skyline. Se L ha lo stesso skyline della matrice iniziale, per cui in generale riempie tutto, per cui se prendete la matrice fatta male come era prima e gli dite di fare la decomposizione ciovesca, gli si prenderà una L triangolare con lo stesso scale line, quindi tutta piena. Perché non preserverà il numero di coefficienti diversi da zero. Riempie tutto. L'unica cosa che preserva è lo skyline. Quindi l'interesse è minimizzare lo skyline, minimizzare la banda. Prima di tuttoare per minimizzare la banda poi fare la decomposizione e poi risolvere ma queste sono cose di algebra numerica che sono studiate ormai da 40 anni 50 anni ci sono degli algoritmi pazzeschi ormai si risolvono in maniera interattiva a miliardi di incognite non c'è più agli inizi una ruotà, adesso proprio. E Matlab devo dire che è veramente efficiente, è veramente super efficiente a risolvere sistemi lineali, raramente c'è qualcosa di più efficiente di Matlab. Poi ci sono delle librerie delicate. Poi c'è l'altro argomento molto interessante, è quello che vi avevo citatoato prima. Sembra un dettaglio, ma veramente non lo è. Come facciamo a stimare a priori quanti coefficienti diversi da zero avremo nella matrice? Come facciamo? Allora, io ho codificato una stima per eccesso banalissima fatta con queste poche righe, che però va abbastanza bene. Il concetto è il seguente. Prendiamo due nodi, il nodo N e il nodo M, e immaginate le loro funzioni di forma globali. Vi ricordate le immagini delle funzioni globali migliorano. Se i due nodi sono lontani, le due funzioni di forma non hanno nessuna intersezione. Quindi, quando io faccio gli integrali relativi alle funzioni di forma di questi due nodi, ottengo 0. Il coefficiente è certamente 0. L'unica possibilità di avere dei coefficienti diversi da 0 nella matrice di rigidezza è quando n ed m sono vicini e i due supporti hanno un'intersezione. Quindi uso questo criterio. Per cui io per ogni nodo, inizializzo una matrice che ha la dimensione dei nodi, è una lista in realtà, una lista che ha la lunghezza di tutti i nodi. Nm, cosa metterò in Nm? Per ogni nodo metto il numero di nodi, quindi di funzioni di forma, che possono interagire con quel nodo lì, nel senso di prima, nel senso che se andrò a calcolare gli integrali delle funzioni globali, si intersecano e quindi danno un contributo. Allora, qui come faccio? Immaginate di trovare un algoritmo che va a vedere quanti sono i nodi con cui questo può interagire. Graficamente è facile, sono tutti i nodi che ho disegnato qua. Questo no, questo no, questo no. Qual è il criterio? Io vado a vedere un nodo e faccio un loop su tutti gli elementi. Se il nodo è nella connettività dell'elemento, allora so che tutti quanti i nodi di quell'elemento interagiranno con il nodo che sto considerando. Altrimenti no. Quanti nodi sono? La prima volta, il primo elemento, avrò sei nodi da aggiungere. Ecco, qui lo si inizializza con sei. Poi, ogni volta che aggiungo un altro elemento, ci sono solo tre nodi nuovi che aggiungo. Per cui, la prima volta, metto sei. Da qualche parte c'è... Ecco, se il numero è zero, cioè se è la prima volta che lo trovo, gli aggio 6 se invece non è la prima volta gli aggiungo C che è 3 cioè ogni volta che trovo un nuovo elemento che contiene quello che mi interessa nella connettività aggiungo 6 o 3 a seconda che sia la prima o non la prima volta che lo trovo quindi alla fine di questo semplicissimo lupo ho questa lista NM che per ogni nodo mi dice per eccesso quanti sono i nodi con cui questo può interagire. Per eccesso perché se fosse su un bordo il numero è esagerato. Provate a immaginare, se sto considerando questo, quella stima è un po' per eccesso. Ma chi se ne frega, io non voglio essere accurato, voglio dargli una stima abbastanza ragionevole. Allora, quindi se io so questo numero, la stima globale dei coefficienti diversi da zero all'interno della matrice sarà la somma di tutti i coefficienti di questo vettore, moltiplicata per 4. Perché per 4? Perché ogni nodo ha due componenti di spostamento, quindi se un nodo interagisce con un altro nodo ci sono 4 coefficienti. Visto che ci sono due gradi di libertà. No, più, perché magari alcuni spostamenti sono noti, perché sono dati dalle condizioni al contorno, quindi questa è una stima per eccesso. Semplicemente con questo piccolo algoritmo ho una stima per eccesso dei coefficienti. Potremmo essere bene divertire anche a dire ok, io ho stimato questi n-coens diversi da zero, andiamo a vedere poi quanti sono effettivamente diversi da zero. E vedrete che un po' di più, ma non tanto. Tanto però, l'algoritmo funziona. Questa è una cosa. Quindi la sparsità della matrice negli elementi finiti è la chiave del successo degli elementi finiti. Se la matrice degli elementi finiti non fosse sparsa, gli elementi finiti avrebbero fatto alla fine un altro metodo che si chiama equazioni integrali BEM invece che BEM il boundary element method in cui io mi occupavo 40 anni fa che generava matrici piene che generava matrici piene morto perché generava matrici piene non si può non ci possiamo permettere di avere matricie. Quindi la sparsità non è un dettaglio. Ultime cose, la convergenza. Nozioni veramente banalissime di convergenza. Allora, c'è una cosa che è molto importante, che si basa sul fatto, su una proprietà degli elementi isoparametrici che abbiamo visto la settimana scorsa, che ogni elemento isoparametrico soddisfa la condizione che si sommate tutte le funzioni di forma, questa da sempre uguale, da sempre uguale, qualunque sia il parametro, l'abbiamo visto per due o trei, ve lo ricordate? È semplice da verificare. Allora, ogni elemento isoparammetrico che ha questa proprietà, cioè tutti gli elementi isoparametrici, sono in grado di rappresentare in maniera esatta un campo a fine di questo genere. Cosa vuol dire? Allora, immaginate di avere fissato A e di aver fissato B e di avere nel vostro spazio questo campo che è uno spazio a fine, cioè la somma di una costante sulla parte lineare. E voi vi volete chiedere se un elemento isoparametrico è in grado di interpolare in maniera esatta questo campo. Allora, l'elemento isoparametrico esprime l'interpolazione sempre nella stessa identica maniera, che qui, ecco, questa è la, scusate, l'elemento isoparametrico, vi ricordo, che è definito da queste due relazioni, lo spostamento e la geometria, lo spostamento e la geometria, che sono molto simili, cioè che X, funzione di A, è uguale alla sommatoria su k di nk, funzione di A, che moltiplica x nk, ok? Questa è la geometria, l'abbiamo già vista tante volte. E lo spostamento, invece, u h, funzione del parametro A, sarà la sommatoria sempre su k di nk, che dipende dai taranti, per unK. Questa è la geometria e questo è lo spostamento. Quindi, se io voglio vedere se il campo, se l'elemento isoparametrico è in grado di rappresentare quel campo, prima di tutto devo definire i valori nodali. E i valori nodali li vado a calcolare esattamente, cioè invece di scrivere unk, scrivo il campo valutato in corrispondenza del nodo. Quindi, la domanda diventa, se io definisco i valori nodali in questa maniera, che è del tutto naturale, prendo il campo che voglio rappresentare e almeno nei nodi voglio che sia quello. Siete d'accordo? Sarà d'assurdo prendo lo sbagliato sui nodi, no? È ovvio che non funziona. Quindi almeno sui nodi lo voglio prendere giusto. E mi chiedo, ma al di fuori dei nodi è giusto, è esatto oppure no? E questa è la domanda che mi faccio. Sui nodi non li pongo io, che si è esatto, ma poi? Allora, separo in due e allora vedrete che avrò questo termine più quest'altro. Ma questa è proprio la geometria. Questo è x, funzione di A. Questo qui è x per come lo costruisco. È proprio questa relazione qua, è come definisco la geometria. Quindi, dato il parametro, x, la posizione geometrica, per me è quella roba lì. Quindi è x. E poi rimane il secondo termine, che quindi, affinché riproduca correttamente il mio campo iniziale, deve dare questa sommatoria uguale a 1. Ma tutti gli elementi isoparametrici garantiscono questa priorità priori.i per cui ogni elemento isoparametrico è in grado di rappresentare in maniera esatta non solo nei nodi un campo a fine questa è la proprietà fondamentale di ogni elemento isoparametrico questo è determinato nello stabilire le proprietà di convergenza io dico solamente questo sappiate che sappiate che ci sono libri, libri, libri, libri, è libero, è politico, adesso appena andate in pensione c'è alguno di queste cose, i parteroni, che ha passato tutta la sua vita a stabilire stime di errore, stime di convergenza, degli elementi finiti, elementi finiti normali, elementi misti, come questi elementi finiti convergono alla soluzione. No. E purtroppo si sa qualcosa nel campo lineare e quando si sposta in campo non lineare alla fine del corso vedremo ad esempio l'elettrostatica non lineare, l'elettromeccanica, ovviamente l'elettromeccanica non lineare e lì si sa poco. Si sa poco. Vabbè, ma gli ingegneri sono tranquilli, se lo fanno, lo aprono, se funziona non funziona, se non funziona non funziona. Metto gli elementi finiti, l'hanno svilupp ma gli ingegneri sono tranquilli, se lo fanno, lo aprono. Se funziona, non funziona, se non funziona, non funziona. Il metodo di elementi finiti l'hanno sviluppato gli ingegneri, i micomatematici. Poi i matematici sono arrivati vent'anni dopo e ci hanno detto perché funzionava, ma noi lo sapevamo già vent'anni. Ovvio che lo si usa con molta più tranquillità se ci sono delle prove di convergenza. Allora, vediamo un po' cosa ci dice. Norme H, la norma H0 è la norma L2, quindi integrate il protoscenario in campo come se stesso, sul volume. La norma H1 invece è la norma L2 più un controllo sul gradiente, se siamo in due dimensioni, quindi integrate anche la norma del gradiente sul dominio. E quindi queste sono le norme, la norma H0 e la norma H1 sono le norme che si utilizzano per stabilire la convergenza dell'errore. Allora, U è la soluzione esatta, UH è la soluzione numerica. Quindi se io voglio calcolare la norma H0 dell'errore, quindi voglio solamente calcolare l'integrale del modulo di questo errore sullo spostamento, allora ho questo risultato qua, cioè che questa è la minore uguale di una costante C0 che dipende solo dalle proprietà del materiale, che moltifica H alla S più 1. Allora, H che cos'è? H è il massimo cerchio circoscritto del triangolo. Queste stime valgono se la mesh è abbastanza uniforme. Se è molto disuniforme, traballano un po'. Però immaginate di avere una mesh uniforme, prendete ogni triangolo, fate il cerchio circoscritto, lo chiamate D, prendete il massimo di D e lo chiamate H. H definisce gli elementi finiti, ormai l'avete capito, P dice H, indica elementi finiti, è la dimensione tipica di elementi finiti. Ognuno ha ritrovato un H e state parlando di elementi finiti. Quindi questa è la taglia della mesh. Quando la mesh viene raffinata, H va a zero. Cos'è s più 1? S è definito da questa cosa. È il minimo fra due numeri. È il minimo fra P e R. Allora, che cosa sono queste due cose? P è facile da capire. È il massimo grado di un polinomio che gli elementi finiti sono in grado di rappresentare in maniera esatta. Abbiamo appena dimostrato che tutti gli elementi finiti isoparometrici sanno rappresentare esattamente un polinomio di ordine 1, con più uguale a 1. Almeno a più uguale a 1 sono tutti capaci. Se saliamo con l'ordine, gli elementi quadratici, se gli elementi quadratici hanno i lati diritti, allora arriviamo a più uguale a 1. Almeno a più uguale a 1 sono tutti capaci. Se saliamo con l'ordine degli elementi quadratici, se gli elementi quadratici hanno i lati diritti, allora arriviamo a più uguale a 2. Se non hanno più gli lati diritti, non arriviamo nemmeno a più uguale a 2. Quindi più uguale a 1 ce l'hanno tutti, più uguale a 2, ci siamo quasi con gli elementi quadratici, ma non proprio. Quindi P è un indice della ricchezza degli elementi finiti più l'elemento finito è ricco è più alto il P R che cos'è? invece è un indice della dolcezza della soluzione se la soluzione non presenta singolarità R è molto alto potrebbe essere infinito se invece labbiamo appena visto, negli spigoli di una molletta, lo sforzo tende ad infinito. Lo sforzo è il gradiente di U, quindi questo R è molto molto basso. Direi che R massimo massimo potrà essere 1 nel caso di una singolarità. Quindi soltanzialmente P indica la ricchezza degli elementi finiti, R è la dolcezza della soluzione. Facciamo due casi estremi. Prendiamo una soluzione dolcissima, quindi R è alto ed il limite è P, quindi è dato dalla ricchezza dell'elemento finito. Allora S sarà uguale a P e quindi H è uguale a P più 1. Cosa vuol dire? Che se abbiamo un elemento finito che ha P uguale a 1, questo converge come H al quadrato. Quindi il rispostamento converge quadraticamente con h. Questa è la norma della soluzione, quindi è quello che è. Quindi quadraticamente con h. Se invece vogliamo controllare la norma h1, che contiene anche il gradiente, cioè ci stiamo chiedendo qual è l'errore che faccio rispetto alla soluzione vera, non solo sulla norma dello spostamento, ma anche sulla sulla norma del gradiente allora purtroppo ne perdo uno di questi esponenti, vedete passo da s più 1 ad s quindi vuol dire che se ho pi uguale ad 1 qui avrò una convergenza lineare solo lineare con la mesh quindi riduco la taglia della mesh ma la convergenza è lenta l'abbiamo app appena visto. L'abbiamo appena visto. Gli elementi finiti comunque fanno fatica a convergere verso una soluzione in sforzi. Facciamo il caso opposto. Il caso opposto è che P non è il problema, ma il problema è la dolcezza della soluzione, è la situazione di quando abbiamo una frattura, quando ci sono le singolarità negli angoli, quando i gradienti sono quindi infiniti. R è molto basso, diventa dunque il fattore limitante e non ha nessun senso usare elementi finiti molto ricchi. Molto spesso non ha neanche senso usare elementi finiti quadratici. E conviene infatti quando si fanno problemi di dinamica non lineare con forti non linearità si usano elementi lineari, intanto anche se passate elementi quadratici la convergenza è limitata dal fatto che la soluzione è poco dolce. Quindi, questo è solo degli elementi banali, rapidissimi, per dirvi attenzione c'è una teoria della convergenza estremamente raffinata, sappiamo che gli spostamenti convergono abbastanza rapidamente, ma se vogliamo controllare i gradienti, ovvero gli sforzi, le deformazioni, quello che ci interessa, ahimè la convergenza è di un ordine più basso in generale. Quindi convergono molto più lentamente. E poi ci sono infinite teorie per la ricostruzione degli sforzi super convergenti, insomma è inutile introdurre queste cose. Ok, allora sentite, io mi fermerei qua.